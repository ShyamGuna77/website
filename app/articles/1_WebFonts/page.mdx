

---
title: "Web Fonts"
description: "Lesson on web fonts from Shyam Guna"
---

## Web Fonts and Typography

![User avatar](./Images/SPD.png)

# Web Fonts

If we want to use a font that doesn't come pre-installed on the user's device, we can download and use a custom font!There are lots of ways to do it. In this lesson, we'll look at a couple popular services that can help, and also see how to do it from scratch.Using Google FontsGoogle Fontsis an online repository of free, open-source web fonts. They have hundreds of popular options.It also effectively works as a CDN for fonts; they serve the fonts for us, from their own servers.Google Fonts works by providing a snippet that looks like this:<linkrel="preconnect"href="https://fonts.gstatic.com"><linkhref="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@1,400;1,600&display=swap"rel="stylesheet">Drop this in the<head>of your HTML file.The snippet will download a stylesheet which downloads a font. We can access that font in our CSS:.thing{font-family:'Open Sans',sans-serif;}Web fonts should be wrapped in quotes ('Open Sans', notOpen Sans). This isn't strictly required if your web font is a single word, but it's a helpful convention: it indicates which fonts in the stack are web fonts vs. local fonts.No HTML file?If you use a framework like Next.js, you may be a bit confused by the lack of anindex.htmlanywhere in the project.Some frameworks generate this file automatically, so that they can include the JS bundles and perform other optimizations.Being able to tweak theindex.htmlis a common task, though, so frameworks will provide escape hatches that let you do this. In Next.js, for example, you can do this withtheHeadcomponent. You might need to do some research to figure out how to do this for your framework of choice.The main benefit to Google Fonts is that it's nice and easy. Drop an HTML snippet in your app, and you're good to go!There are some downsides, though:Lots of amazing fonts aren't available on Google FontsSelf-hosted web fonts can perform betterGatsby creator Kyle Matthews discovered that self-hosting fonts cansave 300ms on desktop, and 1s+ on mobile 3G.Performance trade-offsI was initially surprised to learn that Google Fonts was a bit sluggish. Google is all about speed, why are their servers so slow?It's not actually about server speed, it's about the difference in approach.Show lessLet's explore what happens when we use Google's HTTP snippet:The browser fetches and parses ourindex.htmlfileThe browser sees the<link href="https://fonts.googleapis.com/css2">tag, and fires off a request to fetch a CSS fileThe browser parses the requested CSS file, and discovers that a web font needs to be downloaded fromhttps://fonts.gstatic.com, so it fires off a request for that font file.The CSS file is onfonts.googleapis.comand the font file itself is onfonts.gstatic.com. Because these are both external domains, some additional overhead is required (I'm not an HTTPS expert, but I believe there's some sort of handshake?).The request for the CSS file is blocking; this means that the browser is stuck waiting on this request before it can start rendering the page.When we use a self-hosted web font, by contrast, we can skip one of those steps: we can embed the CSS that fetches the font right in our HTML file, skipping Step #2. And because the font assets are on the same server, we can skip the third-party request overhead.In the old days, this could be offset by the fact that browsers had a global cache; it was possible that your users would already have a cached version of the font, because a different site sourced the font from the same CDN. Due to privacy concerns, however, browsers havestarted using partitioned caches. This means that your users will always need to download your web font on the first visit, even if they've visited other sites using the same font from the same CDN.If you're using Next.js 11 or higher, the framework willautomatically optimize this for you.Using modern toolingVercel, the company behind the Next.js framework, has released an interesting free resource calledFontsource.The idea with Fontsource is that it provides an easy-to-use method to install and useself-hostedweb fonts. It's built specifically for modern JS applications, letting you NPM install the fonts you wish to use. They support all Google Fonts, as well as additional open-source free-to-use fonts.You can learn more byreading their documentation.Angular v11+ has built-in support for Google Fonts, with configuration for inlining the fonts directly. You canlearn more in the Angular docs.The manual wayWhat if you want to use a font that isn't available on Google Fonts or Fontsource?The rest of this lesson shows how to add web fonts "from scratch". Feel free to skip the rest of this lesson if you're happy with another option (though it may still be interesting to learn more about how web fonts work!).Converting formatsThe fonts that run on our computers typically come in.otfor.ttffile formats. These file formats were never intended to be used on the web, and their files tend to be relatively enormous.Our first order of business is to convert our font into a web-friendly format. You can use online converter tools likeFontsquirrel's webfont generator.The font-face tagHow do we tell the browser that we want to use a web font? The@font-faceat-rule has us covered:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-medium.woff2')format('woff2');font-weight:500;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-bold.woff2')format('woff2');font-weight:700;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2');font-weight:400;font-style:italic;}We need multiple statements because each font weight and style has its own file. In this case, I'm loading 3 different font weights (regular, medium, and bold) and an italic variant for the regular weight.The font file itself doesn't contain any "metadata" about what weight/style it is, so we need to link them up. That's what all the declarations in the@font-facestatement are doing. We specify the source for a set of characters (src), and then the associated metadata with that set (font-family,font-weight,font-style).IE supportIn the old days, we needed to supply 3 or 4 font files for each character set, because different browsers supported different formats.These days, things have gotten a lot better. The.woff2format is a modern, highly-optimized format that works across all major browsers, but not in Internet Explorer.My personal opinion is that web fonts are a nice-to-have. I think it's perfectly fine to use a built-in fallback font for IE users. But if you'd prefer that IE users have access to the web font, you'll need to specify a.wofffallback.Show lessYou should already have this file handy, if you used a web font generator or downloaded a web font bundle. They generally convert your font into several common formats.In your@font-facestatement, you can include multiple sources:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2'),url('/fonts/wotfard-regular-italic.woff')format('woff');font-weight:400;font-style:normal;}Be sure to put them in this order, so that.woff2comes first; the browser will download the first recognized format, and we want modern browsers to use.woff2(it tends to produce smaller filesizes).Our goal is to start loading the fonts ASAP, so I like to put these@font-facestatements right in theindex.html:<html><head><style>@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}/* Other @font-face statements omitted for brevity */</style></head>When those@font-facestatements are parsed by the browser, the font file declared undersrcwill be fetched and loaded. You can use the font in your CSS the way you'd use any font:.something{font-family:'Wotfard';font-weight:400;}Static files in ReactOne of the tricky things about React is that you can't access static files like fonts or images in the same way you would in a standard HTML/CSS project.It's beyond the scope of this course, but check out the following guides depending on your generator/meta-framework:create-react-appNext.jsGatsbyFaux bolds and italicsThe@font-facestatement lets us connect a specific font weight value (eg. 700) to a character set. When we use eitherfont-weight: boldorfont-weight: 700, the browser will use the heavier characters instead of the default ones.But what happens if we try to use bold text when we haven't supplied a bold font file?The browser can create "faux" bold text. It achieves this by expanding the thickness of every line in every font, stretching it out in all directions. This tends to create muddy, indistinct letters.For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

There are lots of ways to do it. In this lesson, we'll look at a couple popular services that can help, and also see how to do it from scratch.Using Google FontsGoogle Fontsis an online repository of free, open-source web fonts. They have hundreds of popular options.It also effectively works as a CDN for fonts; they serve the fonts for us, from their own servers.Google Fonts works by providing a snippet that looks like this:<linkrel="preconnect"href="https://fonts.gstatic.com"><linkhref="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@1,400;1,600&display=swap"rel="stylesheet">Drop this in the<head>of your HTML file.The snippet will download a stylesheet which downloads a font. We can access that font in our CSS:.thing{font-family:'Open Sans',sans-serif;}Web fonts should be wrapped in quotes ('Open Sans', notOpen Sans). This isn't strictly required if your web font is a single word, but it's a helpful convention: it indicates which fonts in the stack are web fonts vs. local fonts.No HTML file?If you use a framework like Next.js, you may be a bit confused by the lack of anindex.htmlanywhere in the project.Some frameworks generate this file automatically, so that they can include the JS bundles and perform other optimizations.Being able to tweak theindex.htmlis a common task, though, so frameworks will provide escape hatches that let you do this. In Next.js, for example, you can do this withtheHeadcomponent. You might need to do some research to figure out how to do this for your framework of choice.The main benefit to Google Fonts is that it's nice and easy. Drop an HTML snippet in your app, and you're good to go!There are some downsides, though:Lots of amazing fonts aren't available on Google FontsSelf-hosted web fonts can perform betterGatsby creator Kyle Matthews discovered that self-hosting fonts cansave 300ms on desktop, and 1s+ on mobile 3G.Performance trade-offsI was initially surprised to learn that Google Fonts was a bit sluggish. Google is all about speed, why are their servers so slow?It's not actually about server speed, it's about the difference in approach.Show lessLet's explore what happens when we use Google's HTTP snippet:The browser fetches and parses ourindex.htmlfileThe browser sees the<link href="https://fonts.googleapis.com/css2">tag, and fires off a request to fetch a CSS fileThe browser parses the requested CSS file, and discovers that a web font needs to be downloaded fromhttps://fonts.gstatic.com, so it fires off a request for that font file.The CSS file is onfonts.googleapis.comand the font file itself is onfonts.gstatic.com. Because these are both external domains, some additional overhead is required (I'm not an HTTPS expert, but I believe there's some sort of handshake?).The request for the CSS file is blocking; this means that the browser is stuck waiting on this request before it can start rendering the page.When we use a self-hosted web font, by contrast, we can skip one of those steps: we can embed the CSS that fetches the font right in our HTML file, skipping Step #2. And because the font assets are on the same server, we can skip the third-party request overhead.In the old days, this could be offset by the fact that browsers had a global cache; it was possible that your users would already have a cached version of the font, because a different site sourced the font from the same CDN. Due to privacy concerns, however, browsers havestarted using partitioned caches. This means that your users will always need to download your web font on the first visit, even if they've visited other sites using the same font from the same CDN.If you're using Next.js 11 or higher, the framework willautomatically optimize this for you.Using modern toolingVercel, the company behind the Next.js framework, has released an interesting free resource calledFontsource.The idea with Fontsource is that it provides an easy-to-use method to install and useself-hostedweb fonts. It's built specifically for modern JS applications, letting you NPM install the fonts you wish to use. They support all Google Fonts, as well as additional open-source free-to-use fonts.You can learn more byreading their documentation.Angular v11+ has built-in support for Google Fonts, with configuration for inlining the fonts directly. You canlearn more in the Angular docs.The manual wayWhat if you want to use a font that isn't available on Google Fonts or Fontsource?The rest of this lesson shows how to add web fonts "from scratch". Feel free to skip the rest of this lesson if you're happy with another option (though it may still be interesting to learn more about how web fonts work!).Converting formatsThe fonts that run on our computers typically come in.otfor.ttffile formats. These file formats were never intended to be used on the web, and their files tend to be relatively enormous.Our first order of business is to convert our font into a web-friendly format. You can use online converter tools likeFontsquirrel's webfont generator.The font-face tagHow do we tell the browser that we want to use a web font? The@font-faceat-rule has us covered:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-medium.woff2')format('woff2');font-weight:500;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-bold.woff2')format('woff2');font-weight:700;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2');font-weight:400;font-style:italic;}We need multiple statements because each font weight and style has its own file. In this case, I'm loading 3 different font weights (regular, medium, and bold) and an italic variant for the regular weight.The font file itself doesn't contain any "metadata" about what weight/style it is, so we need to link them up. That's what all the declarations in the@font-facestatement are doing. We specify the source for a set of characters (src), and then the associated metadata with that set (font-family,font-weight,font-style).IE supportIn the old days, we needed to supply 3 or 4 font files for each character set, because different browsers supported different formats.These days, things have gotten a lot better. The.woff2format is a modern, highly-optimized format that works across all major browsers, but not in Internet Explorer.My personal opinion is that web fonts are a nice-to-have. I think it's perfectly fine to use a built-in fallback font for IE users. But if you'd prefer that IE users have access to the web font, you'll need to specify a.wofffallback.Show lessYou should already have this file handy, if you used a web font generator or downloaded a web font bundle. They generally convert your font into several common formats.In your@font-facestatement, you can include multiple sources:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2'),url('/fonts/wotfard-regular-italic.woff')format('woff');font-weight:400;font-style:normal;}Be sure to put them in this order, so that.woff2comes first; the browser will download the first recognized format, and we want modern browsers to use.woff2(it tends to produce smaller filesizes).Our goal is to start loading the fonts ASAP, so I like to put these@font-facestatements right in theindex.html:<html><head><style>@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}/* Other @font-face statements omitted for brevity */</style></head>When those@font-facestatements are parsed by the browser, the font file declared undersrcwill be fetched and loaded. You can use the font in your CSS the way you'd use any font:.something{font-family:'Wotfard';font-weight:400;}Static files in ReactOne of the tricky things about React is that you can't access static files like fonts or images in the same way you would in a standard HTML/CSS project.It's beyond the scope of this course, but check out the following guides depending on your generator/meta-framework:create-react-appNext.jsGatsbyFaux bolds and italicsThe@font-facestatement lets us connect a specific font weight value (eg. 700) to a character set. When we use eitherfont-weight: boldorfont-weight: 700, the browser will use the heavier characters instead of the default ones.But what happens if we try to use bold text when we haven't supplied a bold font file?The browser can create "faux" bold text. It achieves this by expanding the thickness of every line in every font, stretching it out in all directions. This tends to create muddy, indistinct letters.For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

## Using Google Fonts

Google Fontsis an online repository of free, open-source web fonts. They have hundreds of popular options.It also effectively works as a CDN for fonts; they serve the fonts for us, from their own servers.Google Fonts works by providing a snippet that looks like this:<linkrel="preconnect"href="https://fonts.gstatic.com"><linkhref="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@1,400;1,600&display=swap"rel="stylesheet">Drop this in the<head>of your HTML file.The snippet will download a stylesheet which downloads a font. We can access that font in our CSS:.thing{font-family:'Open Sans',sans-serif;}Web fonts should be wrapped in quotes ('Open Sans', notOpen Sans). This isn't strictly required if your web font is a single word, but it's a helpful convention: it indicates which fonts in the stack are web fonts vs. local fonts.No HTML file?If you use a framework like Next.js, you may be a bit confused by the lack of anindex.htmlanywhere in the project.Some frameworks generate this file automatically, so that they can include the JS bundles and perform other optimizations.Being able to tweak theindex.htmlis a common task, though, so frameworks will provide escape hatches that let you do this. In Next.js, for example, you can do this withtheHeadcomponent. You might need to do some research to figure out how to do this for your framework of choice.The main benefit to Google Fonts is that it's nice and easy. Drop an HTML snippet in your app, and you're good to go!There are some downsides, though:Lots of amazing fonts aren't available on Google FontsSelf-hosted web fonts can perform betterGatsby creator Kyle Matthews discovered that self-hosting fonts cansave 300ms on desktop, and 1s+ on mobile 3G.Performance trade-offsI was initially surprised to learn that Google Fonts was a bit sluggish. Google is all about speed, why are their servers so slow?It's not actually about server speed, it's about the difference in approach.Show lessLet's explore what happens when we use Google's HTTP snippet:The browser fetches and parses ourindex.htmlfileThe browser sees the<link href="https://fonts.googleapis.com/css2">tag, and fires off a request to fetch a CSS fileThe browser parses the requested CSS file, and discovers that a web font needs to be downloaded fromhttps://fonts.gstatic.com, so it fires off a request for that font file.The CSS file is onfonts.googleapis.comand the font file itself is onfonts.gstatic.com. Because these are both external domains, some additional overhead is required (I'm not an HTTPS expert, but I believe there's some sort of handshake?).The request for the CSS file is blocking; this means that the browser is stuck waiting on this request before it can start rendering the page.When we use a self-hosted web font, by contrast, we can skip one of those steps: we can embed the CSS that fetches the font right in our HTML file, skipping Step #2. And because the font assets are on the same server, we can skip the third-party request overhead.In the old days, this could be offset by the fact that browsers had a global cache; it was possible that your users would already have a cached version of the font, because a different site sourced the font from the same CDN. Due to privacy concerns, however, browsers havestarted using partitioned caches. This means that your users will always need to download your web font on the first visit, even if they've visited other sites using the same font from the same CDN.If you're using Next.js 11 or higher, the framework willautomatically optimize this for you.Using modern toolingVercel, the company behind the Next.js framework, has released an interesting free resource calledFontsource.The idea with Fontsource is that it provides an easy-to-use method to install and useself-hostedweb fonts. It's built specifically for modern JS applications, letting you NPM install the fonts you wish to use. They support all Google Fonts, as well as additional open-source free-to-use fonts.You can learn more byreading their documentation.Angular v11+ has built-in support for Google Fonts, with configuration for inlining the fonts directly. You canlearn more in the Angular docs.The manual wayWhat if you want to use a font that isn't available on Google Fonts or Fontsource?The rest of this lesson shows how to add web fonts "from scratch". Feel free to skip the rest of this lesson if you're happy with another option (though it may still be interesting to learn more about how web fonts work!).Converting formatsThe fonts that run on our computers typically come in.otfor.ttffile formats. These file formats were never intended to be used on the web, and their files tend to be relatively enormous.Our first order of business is to convert our font into a web-friendly format. You can use online converter tools likeFontsquirrel's webfont generator.The font-face tagHow do we tell the browser that we want to use a web font? The@font-faceat-rule has us covered:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-medium.woff2')format('woff2');font-weight:500;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-bold.woff2')format('woff2');font-weight:700;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2');font-weight:400;font-style:italic;}We need multiple statements because each font weight and style has its own file. In this case, I'm loading 3 different font weights (regular, medium, and bold) and an italic variant for the regular weight.The font file itself doesn't contain any "metadata" about what weight/style it is, so we need to link them up. That's what all the declarations in the@font-facestatement are doing. We specify the source for a set of characters (src), and then the associated metadata with that set (font-family,font-weight,font-style).IE supportIn the old days, we needed to supply 3 or 4 font files for each character set, because different browsers supported different formats.These days, things have gotten a lot better. The.woff2format is a modern, highly-optimized format that works across all major browsers, but not in Internet Explorer.My personal opinion is that web fonts are a nice-to-have. I think it's perfectly fine to use a built-in fallback font for IE users. But if you'd prefer that IE users have access to the web font, you'll need to specify a.wofffallback.Show lessYou should already have this file handy, if you used a web font generator or downloaded a web font bundle. They generally convert your font into several common formats.In your@font-facestatement, you can include multiple sources:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2'),url('/fonts/wotfard-regular-italic.woff')format('woff');font-weight:400;font-style:normal;}Be sure to put them in this order, so that.woff2comes first; the browser will download the first recognized format, and we want modern browsers to use.woff2(it tends to produce smaller filesizes).Our goal is to start loading the fonts ASAP, so I like to put these@font-facestatements right in theindex.html:<html><head><style>@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}/* Other @font-face statements omitted for brevity */</style></head>When those@font-facestatements are parsed by the browser, the font file declared undersrcwill be fetched and loaded. You can use the font in your CSS the way you'd use any font:.something{font-family:'Wotfard';font-weight:400;}Static files in ReactOne of the tricky things about React is that you can't access static files like fonts or images in the same way you would in a standard HTML/CSS project.It's beyond the scope of this course, but check out the following guides depending on your generator/meta-framework:create-react-appNext.jsGatsbyFaux bolds and italicsThe@font-facestatement lets us connect a specific font weight value (eg. 700) to a character set. When we use eitherfont-weight: boldorfont-weight: 700, the browser will use the heavier characters instead of the default ones.But what happens if we try to use bold text when we haven't supplied a bold font file?The browser can create "faux" bold text. It achieves this by expanding the thickness of every line in every font, stretching it out in all directions. This tends to create muddy, indistinct letters.For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

It also effectively works as a CDN for fonts; they serve the fonts for us, from their own servers.Google Fonts works by providing a snippet that looks like this:<linkrel="preconnect"href="https://fonts.gstatic.com"><linkhref="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@1,400;1,600&display=swap"rel="stylesheet">Drop this in the<head>of your HTML file.The snippet will download a stylesheet which downloads a font. We can access that font in our CSS:.thing{font-family:'Open Sans',sans-serif;}Web fonts should be wrapped in quotes ('Open Sans', notOpen Sans). This isn't strictly required if your web font is a single word, but it's a helpful convention: it indicates which fonts in the stack are web fonts vs. local fonts.No HTML file?If you use a framework like Next.js, you may be a bit confused by the lack of anindex.htmlanywhere in the project.Some frameworks generate this file automatically, so that they can include the JS bundles and perform other optimizations.Being able to tweak theindex.htmlis a common task, though, so frameworks will provide escape hatches that let you do this. In Next.js, for example, you can do this withtheHeadcomponent. You might need to do some research to figure out how to do this for your framework of choice.The main benefit to Google Fonts is that it's nice and easy. Drop an HTML snippet in your app, and you're good to go!There are some downsides, though:Lots of amazing fonts aren't available on Google FontsSelf-hosted web fonts can perform betterGatsby creator Kyle Matthews discovered that self-hosting fonts cansave 300ms on desktop, and 1s+ on mobile 3G.Performance trade-offsI was initially surprised to learn that Google Fonts was a bit sluggish. Google is all about speed, why are their servers so slow?It's not actually about server speed, it's about the difference in approach.Show lessLet's explore what happens when we use Google's HTTP snippet:The browser fetches and parses ourindex.htmlfileThe browser sees the<link href="https://fonts.googleapis.com/css2">tag, and fires off a request to fetch a CSS fileThe browser parses the requested CSS file, and discovers that a web font needs to be downloaded fromhttps://fonts.gstatic.com, so it fires off a request for that font file.The CSS file is onfonts.googleapis.comand the font file itself is onfonts.gstatic.com. Because these are both external domains, some additional overhead is required (I'm not an HTTPS expert, but I believe there's some sort of handshake?).The request for the CSS file is blocking; this means that the browser is stuck waiting on this request before it can start rendering the page.When we use a self-hosted web font, by contrast, we can skip one of those steps: we can embed the CSS that fetches the font right in our HTML file, skipping Step #2. And because the font assets are on the same server, we can skip the third-party request overhead.In the old days, this could be offset by the fact that browsers had a global cache; it was possible that your users would already have a cached version of the font, because a different site sourced the font from the same CDN. Due to privacy concerns, however, browsers havestarted using partitioned caches. This means that your users will always need to download your web font on the first visit, even if they've visited other sites using the same font from the same CDN.If you're using Next.js 11 or higher, the framework willautomatically optimize this for you.Using modern toolingVercel, the company behind the Next.js framework, has released an interesting free resource calledFontsource.The idea with Fontsource is that it provides an easy-to-use method to install and useself-hostedweb fonts. It's built specifically for modern JS applications, letting you NPM install the fonts you wish to use. They support all Google Fonts, as well as additional open-source free-to-use fonts.You can learn more byreading their documentation.Angular v11+ has built-in support for Google Fonts, with configuration for inlining the fonts directly. You canlearn more in the Angular docs.The manual wayWhat if you want to use a font that isn't available on Google Fonts or Fontsource?The rest of this lesson shows how to add web fonts "from scratch". Feel free to skip the rest of this lesson if you're happy with another option (though it may still be interesting to learn more about how web fonts work!).Converting formatsThe fonts that run on our computers typically come in.otfor.ttffile formats. These file formats were never intended to be used on the web, and their files tend to be relatively enormous.Our first order of business is to convert our font into a web-friendly format. You can use online converter tools likeFontsquirrel's webfont generator.The font-face tagHow do we tell the browser that we want to use a web font? The@font-faceat-rule has us covered:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-medium.woff2')format('woff2');font-weight:500;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-bold.woff2')format('woff2');font-weight:700;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2');font-weight:400;font-style:italic;}We need multiple statements because each font weight and style has its own file. In this case, I'm loading 3 different font weights (regular, medium, and bold) and an italic variant for the regular weight.The font file itself doesn't contain any "metadata" about what weight/style it is, so we need to link them up. That's what all the declarations in the@font-facestatement are doing. We specify the source for a set of characters (src), and then the associated metadata with that set (font-family,font-weight,font-style).IE supportIn the old days, we needed to supply 3 or 4 font files for each character set, because different browsers supported different formats.These days, things have gotten a lot better. The.woff2format is a modern, highly-optimized format that works across all major browsers, but not in Internet Explorer.My personal opinion is that web fonts are a nice-to-have. I think it's perfectly fine to use a built-in fallback font for IE users. But if you'd prefer that IE users have access to the web font, you'll need to specify a.wofffallback.Show lessYou should already have this file handy, if you used a web font generator or downloaded a web font bundle. They generally convert your font into several common formats.In your@font-facestatement, you can include multiple sources:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2'),url('/fonts/wotfard-regular-italic.woff')format('woff');font-weight:400;font-style:normal;}Be sure to put them in this order, so that.woff2comes first; the browser will download the first recognized format, and we want modern browsers to use.woff2(it tends to produce smaller filesizes).Our goal is to start loading the fonts ASAP, so I like to put these@font-facestatements right in theindex.html:<html><head><style>@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}/* Other @font-face statements omitted for brevity */</style></head>When those@font-facestatements are parsed by the browser, the font file declared undersrcwill be fetched and loaded. You can use the font in your CSS the way you'd use any font:.something{font-family:'Wotfard';font-weight:400;}Static files in ReactOne of the tricky things about React is that you can't access static files like fonts or images in the same way you would in a standard HTML/CSS project.It's beyond the scope of this course, but check out the following guides depending on your generator/meta-framework:create-react-appNext.jsGatsbyFaux bolds and italicsThe@font-facestatement lets us connect a specific font weight value (eg. 700) to a character set. When we use eitherfont-weight: boldorfont-weight: 700, the browser will use the heavier characters instead of the default ones.But what happens if we try to use bold text when we haven't supplied a bold font file?The browser can create "faux" bold text. It achieves this by expanding the thickness of every line in every font, stretching it out in all directions. This tends to create muddy, indistinct letters.For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

Google Fonts works by providing a snippet that looks like this:<linkrel="preconnect"href="https://fonts.gstatic.com"><linkhref="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@1,400;1,600&display=swap"rel="stylesheet">Drop this in the<head>of your HTML file.The snippet will download a stylesheet which downloads a font. We can access that font in our CSS:.thing{font-family:'Open Sans',sans-serif;}Web fonts should be wrapped in quotes ('Open Sans', notOpen Sans). This isn't strictly required if your web font is a single word, but it's a helpful convention: it indicates which fonts in the stack are web fonts vs. local fonts.No HTML file?If you use a framework like Next.js, you may be a bit confused by the lack of anindex.htmlanywhere in the project.Some frameworks generate this file automatically, so that they can include the JS bundles and perform other optimizations.Being able to tweak theindex.htmlis a common task, though, so frameworks will provide escape hatches that let you do this. In Next.js, for example, you can do this withtheHeadcomponent. You might need to do some research to figure out how to do this for your framework of choice.The main benefit to Google Fonts is that it's nice and easy. Drop an HTML snippet in your app, and you're good to go!There are some downsides, though:Lots of amazing fonts aren't available on Google FontsSelf-hosted web fonts can perform betterGatsby creator Kyle Matthews discovered that self-hosting fonts cansave 300ms on desktop, and 1s+ on mobile 3G.Performance trade-offsI was initially surprised to learn that Google Fonts was a bit sluggish. Google is all about speed, why are their servers so slow?It's not actually about server speed, it's about the difference in approach.Show lessLet's explore what happens when we use Google's HTTP snippet:The browser fetches and parses ourindex.htmlfileThe browser sees the<link href="https://fonts.googleapis.com/css2">tag, and fires off a request to fetch a CSS fileThe browser parses the requested CSS file, and discovers that a web font needs to be downloaded fromhttps://fonts.gstatic.com, so it fires off a request for that font file.The CSS file is onfonts.googleapis.comand the font file itself is onfonts.gstatic.com. Because these are both external domains, some additional overhead is required (I'm not an HTTPS expert, but I believe there's some sort of handshake?).The request for the CSS file is blocking; this means that the browser is stuck waiting on this request before it can start rendering the page.When we use a self-hosted web font, by contrast, we can skip one of those steps: we can embed the CSS that fetches the font right in our HTML file, skipping Step #2. And because the font assets are on the same server, we can skip the third-party request overhead.In the old days, this could be offset by the fact that browsers had a global cache; it was possible that your users would already have a cached version of the font, because a different site sourced the font from the same CDN. Due to privacy concerns, however, browsers havestarted using partitioned caches. This means that your users will always need to download your web font on the first visit, even if they've visited other sites using the same font from the same CDN.If you're using Next.js 11 or higher, the framework willautomatically optimize this for you.Using modern toolingVercel, the company behind the Next.js framework, has released an interesting free resource calledFontsource.The idea with Fontsource is that it provides an easy-to-use method to install and useself-hostedweb fonts. It's built specifically for modern JS applications, letting you NPM install the fonts you wish to use. They support all Google Fonts, as well as additional open-source free-to-use fonts.You can learn more byreading their documentation.Angular v11+ has built-in support for Google Fonts, with configuration for inlining the fonts directly. You canlearn more in the Angular docs.The manual wayWhat if you want to use a font that isn't available on Google Fonts or Fontsource?The rest of this lesson shows how to add web fonts "from scratch". Feel free to skip the rest of this lesson if you're happy with another option (though it may still be interesting to learn more about how web fonts work!).Converting formatsThe fonts that run on our computers typically come in.otfor.ttffile formats. These file formats were never intended to be used on the web, and their files tend to be relatively enormous.Our first order of business is to convert our font into a web-friendly format. You can use online converter tools likeFontsquirrel's webfont generator.The font-face tagHow do we tell the browser that we want to use a web font? The@font-faceat-rule has us covered:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-medium.woff2')format('woff2');font-weight:500;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-bold.woff2')format('woff2');font-weight:700;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2');font-weight:400;font-style:italic;}We need multiple statements because each font weight and style has its own file. In this case, I'm loading 3 different font weights (regular, medium, and bold) and an italic variant for the regular weight.The font file itself doesn't contain any "metadata" about what weight/style it is, so we need to link them up. That's what all the declarations in the@font-facestatement are doing. We specify the source for a set of characters (src), and then the associated metadata with that set (font-family,font-weight,font-style).IE supportIn the old days, we needed to supply 3 or 4 font files for each character set, because different browsers supported different formats.These days, things have gotten a lot better. The.woff2format is a modern, highly-optimized format that works across all major browsers, but not in Internet Explorer.My personal opinion is that web fonts are a nice-to-have. I think it's perfectly fine to use a built-in fallback font for IE users. But if you'd prefer that IE users have access to the web font, you'll need to specify a.wofffallback.Show lessYou should already have this file handy, if you used a web font generator or downloaded a web font bundle. They generally convert your font into several common formats.In your@font-facestatement, you can include multiple sources:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2'),url('/fonts/wotfard-regular-italic.woff')format('woff');font-weight:400;font-style:normal;}Be sure to put them in this order, so that.woff2comes first; the browser will download the first recognized format, and we want modern browsers to use.woff2(it tends to produce smaller filesizes).Our goal is to start loading the fonts ASAP, so I like to put these@font-facestatements right in theindex.html:<html><head><style>@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}/* Other @font-face statements omitted for brevity */</style></head>When those@font-facestatements are parsed by the browser, the font file declared undersrcwill be fetched and loaded. You can use the font in your CSS the way you'd use any font:.something{font-family:'Wotfard';font-weight:400;}Static files in ReactOne of the tricky things about React is that you can't access static files like fonts or images in the same way you would in a standard HTML/CSS project.It's beyond the scope of this course, but check out the following guides depending on your generator/meta-framework:create-react-appNext.jsGatsbyFaux bolds and italicsThe@font-facestatement lets us connect a specific font weight value (eg. 700) to a character set. When we use eitherfont-weight: boldorfont-weight: 700, the browser will use the heavier characters instead of the default ones.But what happens if we try to use bold text when we haven't supplied a bold font file?The browser can create "faux" bold text. It achieves this by expanding the thickness of every line in every font, stretching it out in all directions. This tends to create muddy, indistinct letters.For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

```js
<link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@1,400;1,600&display=swap" rel="stylesheet">
```

Drop this in the<head>of your HTML file.The snippet will download a stylesheet which downloads a font. We can access that font in our CSS:.thing{font-family:'Open Sans',sans-serif;}Web fonts should be wrapped in quotes ('Open Sans', notOpen Sans). This isn't strictly required if your web font is a single word, but it's a helpful convention: it indicates which fonts in the stack are web fonts vs. local fonts.No HTML file?If you use a framework like Next.js, you may be a bit confused by the lack of anindex.htmlanywhere in the project.Some frameworks generate this file automatically, so that they can include the JS bundles and perform other optimizations.Being able to tweak theindex.htmlis a common task, though, so frameworks will provide escape hatches that let you do this. In Next.js, for example, you can do this withtheHeadcomponent. You might need to do some research to figure out how to do this for your framework of choice.The main benefit to Google Fonts is that it's nice and easy. Drop an HTML snippet in your app, and you're good to go!There are some downsides, though:Lots of amazing fonts aren't available on Google FontsSelf-hosted web fonts can perform betterGatsby creator Kyle Matthews discovered that self-hosting fonts cansave 300ms on desktop, and 1s+ on mobile 3G.Performance trade-offsI was initially surprised to learn that Google Fonts was a bit sluggish. Google is all about speed, why are their servers so slow?It's not actually about server speed, it's about the difference in approach.Show lessLet's explore what happens when we use Google's HTTP snippet:The browser fetches and parses ourindex.htmlfileThe browser sees the<link href="https://fonts.googleapis.com/css2">tag, and fires off a request to fetch a CSS fileThe browser parses the requested CSS file, and discovers that a web font needs to be downloaded fromhttps://fonts.gstatic.com, so it fires off a request for that font file.The CSS file is onfonts.googleapis.comand the font file itself is onfonts.gstatic.com. Because these are both external domains, some additional overhead is required (I'm not an HTTPS expert, but I believe there's some sort of handshake?).The request for the CSS file is blocking; this means that the browser is stuck waiting on this request before it can start rendering the page.When we use a self-hosted web font, by contrast, we can skip one of those steps: we can embed the CSS that fetches the font right in our HTML file, skipping Step #2. And because the font assets are on the same server, we can skip the third-party request overhead.In the old days, this could be offset by the fact that browsers had a global cache; it was possible that your users would already have a cached version of the font, because a different site sourced the font from the same CDN. Due to privacy concerns, however, browsers havestarted using partitioned caches. This means that your users will always need to download your web font on the first visit, even if they've visited other sites using the same font from the same CDN.If you're using Next.js 11 or higher, the framework willautomatically optimize this for you.Using modern toolingVercel, the company behind the Next.js framework, has released an interesting free resource calledFontsource.The idea with Fontsource is that it provides an easy-to-use method to install and useself-hostedweb fonts. It's built specifically for modern JS applications, letting you NPM install the fonts you wish to use. They support all Google Fonts, as well as additional open-source free-to-use fonts.You can learn more byreading their documentation.Angular v11+ has built-in support for Google Fonts, with configuration for inlining the fonts directly. You canlearn more in the Angular docs.The manual wayWhat if you want to use a font that isn't available on Google Fonts or Fontsource?The rest of this lesson shows how to add web fonts "from scratch". Feel free to skip the rest of this lesson if you're happy with another option (though it may still be interesting to learn more about how web fonts work!).Converting formatsThe fonts that run on our computers typically come in.otfor.ttffile formats. These file formats were never intended to be used on the web, and their files tend to be relatively enormous.Our first order of business is to convert our font into a web-friendly format. You can use online converter tools likeFontsquirrel's webfont generator.The font-face tagHow do we tell the browser that we want to use a web font? The@font-faceat-rule has us covered:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-medium.woff2')format('woff2');font-weight:500;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-bold.woff2')format('woff2');font-weight:700;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2');font-weight:400;font-style:italic;}We need multiple statements because each font weight and style has its own file. In this case, I'm loading 3 different font weights (regular, medium, and bold) and an italic variant for the regular weight.The font file itself doesn't contain any "metadata" about what weight/style it is, so we need to link them up. That's what all the declarations in the@font-facestatement are doing. We specify the source for a set of characters (src), and then the associated metadata with that set (font-family,font-weight,font-style).IE supportIn the old days, we needed to supply 3 or 4 font files for each character set, because different browsers supported different formats.These days, things have gotten a lot better. The.woff2format is a modern, highly-optimized format that works across all major browsers, but not in Internet Explorer.My personal opinion is that web fonts are a nice-to-have. I think it's perfectly fine to use a built-in fallback font for IE users. But if you'd prefer that IE users have access to the web font, you'll need to specify a.wofffallback.Show lessYou should already have this file handy, if you used a web font generator or downloaded a web font bundle. They generally convert your font into several common formats.In your@font-facestatement, you can include multiple sources:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2'),url('/fonts/wotfard-regular-italic.woff')format('woff');font-weight:400;font-style:normal;}Be sure to put them in this order, so that.woff2comes first; the browser will download the first recognized format, and we want modern browsers to use.woff2(it tends to produce smaller filesizes).Our goal is to start loading the fonts ASAP, so I like to put these@font-facestatements right in theindex.html:<html><head><style>@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}/* Other @font-face statements omitted for brevity */</style></head>When those@font-facestatements are parsed by the browser, the font file declared undersrcwill be fetched and loaded. You can use the font in your CSS the way you'd use any font:.something{font-family:'Wotfard';font-weight:400;}Static files in ReactOne of the tricky things about React is that you can't access static files like fonts or images in the same way you would in a standard HTML/CSS project.It's beyond the scope of this course, but check out the following guides depending on your generator/meta-framework:create-react-appNext.jsGatsbyFaux bolds and italicsThe@font-facestatement lets us connect a specific font weight value (eg. 700) to a character set. When we use eitherfont-weight: boldorfont-weight: 700, the browser will use the heavier characters instead of the default ones.But what happens if we try to use bold text when we haven't supplied a bold font file?The browser can create "faux" bold text. It achieves this by expanding the thickness of every line in every font, stretching it out in all directions. This tends to create muddy, indistinct letters.For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.


The snippet will download a stylesheet which downloads a font. We can access that font in our CSS:.thing{font-family:'Open Sans',sans-serif;}Web fonts should be wrapped in quotes ('Open Sans', notOpen Sans). This isn't strictly required if your web font is a single word, but it's a helpful convention: it indicates which fonts in the stack are web fonts vs. local fonts.No HTML file?If you use a framework like Next.js, you may be a bit confused by the lack of anindex.htmlanywhere in the project.Some frameworks generate this file automatically, so that they can include the JS bundles and perform other optimizations.Being able to tweak theindex.htmlis a common task, though, so frameworks will provide escape hatches that let you do this. In Next.js, for example, you can do this withtheHeadcomponent. You might need to do some research to figure out how to do this for your framework of choice.The main benefit to Google Fonts is that it's nice and easy. Drop an HTML snippet in your app, and you're good to go!There are some downsides, though:Lots of amazing fonts aren't available on Google FontsSelf-hosted web fonts can perform betterGatsby creator Kyle Matthews discovered that self-hosting fonts cansave 300ms on desktop, and 1s+ on mobile 3G.Performance trade-offsI was initially surprised to learn that Google Fonts was a bit sluggish. Google is all about speed, why are their servers so slow?It's not actually about server speed, it's about the difference in approach.Show lessLet's explore what happens when we use Google's HTTP snippet:The browser fetches and parses ourindex.htmlfileThe browser sees the<link href="https://fonts.googleapis.com/css2">tag, and fires off a request to fetch a CSS fileThe browser parses the requested CSS file, and discovers that a web font needs to be downloaded fromhttps://fonts.gstatic.com, so it fires off a request for that font file.The CSS file is onfonts.googleapis.comand the font file itself is onfonts.gstatic.com. Because these are both external domains, some additional overhead is required (I'm not an HTTPS expert, but I believe there's some sort of handshake?).The request for the CSS file is blocking; this means that the browser is stuck waiting on this request before it can start rendering the page.When we use a self-hosted web font, by contrast, we can skip one of those steps: we can embed the CSS that fetches the font right in our HTML file, skipping Step #2. And because the font assets are on the same server, we can skip the third-party request overhead.In the old days, this could be offset by the fact that browsers had a global cache; it was possible that your users would already have a cached version of the font, because a different site sourced the font from the same CDN. Due to privacy concerns, however, browsers havestarted using partitioned caches. This means that your users will always need to download your web font on the first visit, even if they've visited other sites using the same font from the same CDN.If you're using Next.js 11 or higher, the framework willautomatically optimize this for you.Using modern toolingVercel, the company behind the Next.js framework, has released an interesting free resource calledFontsource.The idea with Fontsource is that it provides an easy-to-use method to install and useself-hostedweb fonts. It's built specifically for modern JS applications, letting you NPM install the fonts you wish to use. They support all Google Fonts, as well as additional open-source free-to-use fonts.You can learn more byreading their documentation.Angular v11+ has built-in support for Google Fonts, with configuration for inlining the fonts directly. You canlearn more in the Angular docs.The manual wayWhat if you want to use a font that isn't available on Google Fonts or Fontsource?The rest of this lesson shows how to add web fonts "from scratch". Feel free to skip the rest of this lesson if you're happy with another option (though it may still be interesting to learn more about how web fonts work!).Converting formatsThe fonts that run on our computers typically come in.otfor.ttffile formats. These file formats were never intended to be used on the web, and their files tend to be relatively enormous.Our first order of business is to convert our font into a web-friendly format. You can use online converter tools likeFontsquirrel's webfont generator.The font-face tagHow do we tell the browser that we want to use a web font? The@font-faceat-rule has us covered:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-medium.woff2')format('woff2');font-weight:500;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-bold.woff2')format('woff2');font-weight:700;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2');font-weight:400;font-style:italic;}We need multiple statements because each font weight and style has its own file. In this case, I'm loading 3 different font weights (regular, medium, and bold) and an italic variant for the regular weight.The font file itself doesn't contain any "metadata" about what weight/style it is, so we need to link them up. That's what all the declarations in the@font-facestatement are doing. We specify the source for a set of characters (src), and then the associated metadata with that set (font-family,font-weight,font-style).IE supportIn the old days, we needed to supply 3 or 4 font files for each character set, because different browsers supported different formats.These days, things have gotten a lot better. The.woff2format is a modern, highly-optimized format that works across all major browsers, but not in Internet Explorer.My personal opinion is that web fonts are a nice-to-have. I think it's perfectly fine to use a built-in fallback font for IE users. But if you'd prefer that IE users have access to the web font, you'll need to specify a.wofffallback.Show lessYou should already have this file handy, if you used a web font generator or downloaded a web font bundle. They generally convert your font into several common formats.In your@font-facestatement, you can include multiple sources:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2'),url('/fonts/wotfard-regular-italic.woff')format('woff');font-weight:400;font-style:normal;}Be sure to put them in this order, so that.woff2comes first; the browser will download the first recognized format, and we want modern browsers to use.woff2(it tends to produce smaller filesizes).Our goal is to start loading the fonts ASAP, so I like to put these@font-facestatements right in theindex.html:<html><head><style>@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}/* Other @font-face statements omitted for brevity */</style></head>When those@font-facestatements are parsed by the browser, the font file declared undersrcwill be fetched and loaded. You can use the font in your CSS the way you'd use any font:.something{font-family:'Wotfard';font-weight:400;}Static files in ReactOne of the tricky things about React is that you can't access static files like fonts or images in the same way you would in a standard HTML/CSS project.It's beyond the scope of this course, but check out the following guides depending on your generator/meta-framework:create-react-appNext.jsGatsbyFaux bolds and italicsThe@font-facestatement lets us connect a specific font weight value (eg. 700) to a character set. When we use eitherfont-weight: boldorfont-weight: 700, the browser will use the heavier characters instead of the default ones.But what happens if we try to use bold text when we haven't supplied a bold font file?The browser can create "faux" bold text. It achieves this by expanding the thickness of every line in every font, stretching it out in all directions. This tends to create muddy, indistinct letters.For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

```js
.thing {  font-family: 'Open Sans', sans-serif;}
```

Web fonts should be wrapped in quotes ('Open Sans', notOpen Sans). This isn't strictly required if your web font is a single word, but it's a helpful convention: it indicates which fonts in the stack are web fonts vs. local fonts.No HTML file?If you use a framework like Next.js, you may be a bit confused by the lack of anindex.htmlanywhere in the project.Some frameworks generate this file automatically, so that they can include the JS bundles and perform other optimizations.Being able to tweak theindex.htmlis a common task, though, so frameworks will provide escape hatches that let you do this. In Next.js, for example, you can do this withtheHeadcomponent. You might need to do some research to figure out how to do this for your framework of choice.The main benefit to Google Fonts is that it's nice and easy. Drop an HTML snippet in your app, and you're good to go!There are some downsides, though:Lots of amazing fonts aren't available on Google FontsSelf-hosted web fonts can perform betterGatsby creator Kyle Matthews discovered that self-hosting fonts cansave 300ms on desktop, and 1s+ on mobile 3G.Performance trade-offsI was initially surprised to learn that Google Fonts was a bit sluggish. Google is all about speed, why are their servers so slow?It's not actually about server speed, it's about the difference in approach.Show lessLet's explore what happens when we use Google's HTTP snippet:The browser fetches and parses ourindex.htmlfileThe browser sees the<link href="https://fonts.googleapis.com/css2">tag, and fires off a request to fetch a CSS fileThe browser parses the requested CSS file, and discovers that a web font needs to be downloaded fromhttps://fonts.gstatic.com, so it fires off a request for that font file.The CSS file is onfonts.googleapis.comand the font file itself is onfonts.gstatic.com. Because these are both external domains, some additional overhead is required (I'm not an HTTPS expert, but I believe there's some sort of handshake?).The request for the CSS file is blocking; this means that the browser is stuck waiting on this request before it can start rendering the page.When we use a self-hosted web font, by contrast, we can skip one of those steps: we can embed the CSS that fetches the font right in our HTML file, skipping Step #2. And because the font assets are on the same server, we can skip the third-party request overhead.In the old days, this could be offset by the fact that browsers had a global cache; it was possible that your users would already have a cached version of the font, because a different site sourced the font from the same CDN. Due to privacy concerns, however, browsers havestarted using partitioned caches. This means that your users will always need to download your web font on the first visit, even if they've visited other sites using the same font from the same CDN.If you're using Next.js 11 or higher, the framework willautomatically optimize this for you.Using modern toolingVercel, the company behind the Next.js framework, has released an interesting free resource calledFontsource.The idea with Fontsource is that it provides an easy-to-use method to install and useself-hostedweb fonts. It's built specifically for modern JS applications, letting you NPM install the fonts you wish to use. They support all Google Fonts, as well as additional open-source free-to-use fonts.You can learn more byreading their documentation.Angular v11+ has built-in support for Google Fonts, with configuration for inlining the fonts directly. You canlearn more in the Angular docs.The manual wayWhat if you want to use a font that isn't available on Google Fonts or Fontsource?The rest of this lesson shows how to add web fonts "from scratch". Feel free to skip the rest of this lesson if you're happy with another option (though it may still be interesting to learn more about how web fonts work!).Converting formatsThe fonts that run on our computers typically come in.otfor.ttffile formats. These file formats were never intended to be used on the web, and their files tend to be relatively enormous.Our first order of business is to convert our font into a web-friendly format. You can use online converter tools likeFontsquirrel's webfont generator.The font-face tagHow do we tell the browser that we want to use a web font? The@font-faceat-rule has us covered:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-medium.woff2')format('woff2');font-weight:500;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-bold.woff2')format('woff2');font-weight:700;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2');font-weight:400;font-style:italic;}We need multiple statements because each font weight and style has its own file. In this case, I'm loading 3 different font weights (regular, medium, and bold) and an italic variant for the regular weight.The font file itself doesn't contain any "metadata" about what weight/style it is, so we need to link them up. That's what all the declarations in the@font-facestatement are doing. We specify the source for a set of characters (src), and then the associated metadata with that set (font-family,font-weight,font-style).IE supportIn the old days, we needed to supply 3 or 4 font files for each character set, because different browsers supported different formats.These days, things have gotten a lot better. The.woff2format is a modern, highly-optimized format that works across all major browsers, but not in Internet Explorer.My personal opinion is that web fonts are a nice-to-have. I think it's perfectly fine to use a built-in fallback font for IE users. But if you'd prefer that IE users have access to the web font, you'll need to specify a.wofffallback.Show lessYou should already have this file handy, if you used a web font generator or downloaded a web font bundle. They generally convert your font into several common formats.In your@font-facestatement, you can include multiple sources:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2'),url('/fonts/wotfard-regular-italic.woff')format('woff');font-weight:400;font-style:normal;}Be sure to put them in this order, so that.woff2comes first; the browser will download the first recognized format, and we want modern browsers to use.woff2(it tends to produce smaller filesizes).Our goal is to start loading the fonts ASAP, so I like to put these@font-facestatements right in theindex.html:<html><head><style>@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}/* Other @font-face statements omitted for brevity */</style></head>When those@font-facestatements are parsed by the browser, the font file declared undersrcwill be fetched and loaded. You can use the font in your CSS the way you'd use any font:.something{font-family:'Wotfard';font-weight:400;}Static files in ReactOne of the tricky things about React is that you can't access static files like fonts or images in the same way you would in a standard HTML/CSS project.It's beyond the scope of this course, but check out the following guides depending on your generator/meta-framework:create-react-appNext.jsGatsbyFaux bolds and italicsThe@font-facestatement lets us connect a specific font weight value (eg. 700) to a character set. When we use eitherfont-weight: boldorfont-weight: 700, the browser will use the heavier characters instead of the default ones.But what happens if we try to use bold text when we haven't supplied a bold font file?The browser can create "faux" bold text. It achieves this by expanding the thickness of every line in every font, stretching it out in all directions. This tends to create muddy, indistinct letters.For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.



If you use a framework like Next.js, you may be a bit confused by the lack of anindex.htmlanywhere in the project.Some frameworks generate this file automatically, so that they can include the JS bundles and perform other optimizations.Being able to tweak theindex.htmlis a common task, though, so frameworks will provide escape hatches that let you do this. In Next.js, for example, you can do this withtheHeadcomponent. You might need to do some research to figure out how to do this for your framework of choice.


Some frameworks generate this file automatically, so that they can include the JS bundles and perform other optimizations.Being able to tweak theindex.htmlis a common task, though, so frameworks will provide escape hatches that let you do this. In Next.js, for example, you can do this withtheHeadcomponent. You might need to do some research to figure out how to do this for your framework of choice.

Being able to tweak theindex.htmlis a common task, though, so frameworks will provide escape hatches that let you do this. In Next.js, for example, you can do this withtheHeadcomponent. You might need to do some research to figure out how to do this for your framework of choice.



The main benefit to Google Fonts is that it's nice and easy. Drop an HTML snippet in your app, and you're good to go!There are some downsides, though:Lots of amazing fonts aren't available on Google FontsSelf-hosted web fonts can perform betterGatsby creator Kyle Matthews discovered that self-hosting fonts cansave 300ms on desktop, and 1s+ on mobile 3G.Performance trade-offsI was initially surprised to learn that Google Fonts was a bit sluggish. Google is all about speed, why are their servers so slow?It's not actually about server speed, it's about the difference in approach.Show lessLet's explore what happens when we use Google's HTTP snippet:The browser fetches and parses ourindex.htmlfileThe browser sees the<link href="https://fonts.googleapis.com/css2">tag, and fires off a request to fetch a CSS fileThe browser parses the requested CSS file, and discovers that a web font needs to be downloaded fromhttps://fonts.gstatic.com, so it fires off a request for that font file.The CSS file is onfonts.googleapis.comand the font file itself is onfonts.gstatic.com. Because these are both external domains, some additional overhead is required (I'm not an HTTPS expert, but I believe there's some sort of handshake?).The request for the CSS file is blocking; this means that the browser is stuck waiting on this request before it can start rendering the page.When we use a self-hosted web font, by contrast, we can skip one of those steps: we can embed the CSS that fetches the font right in our HTML file, skipping Step #2. And because the font assets are on the same server, we can skip the third-party request overhead.In the old days, this could be offset by the fact that browsers had a global cache; it was possible that your users would already have a cached version of the font, because a different site sourced the font from the same CDN. Due to privacy concerns, however, browsers havestarted using partitioned caches. This means that your users will always need to download your web font on the first visit, even if they've visited other sites using the same font from the same CDN.If you're using Next.js 11 or higher, the framework willautomatically optimize this for you.Using modern toolingVercel, the company behind the Next.js framework, has released an interesting free resource calledFontsource.The idea with Fontsource is that it provides an easy-to-use method to install and useself-hostedweb fonts. It's built specifically for modern JS applications, letting you NPM install the fonts you wish to use. They support all Google Fonts, as well as additional open-source free-to-use fonts.You can learn more byreading their documentation.Angular v11+ has built-in support for Google Fonts, with configuration for inlining the fonts directly. You canlearn more in the Angular docs.The manual wayWhat if you want to use a font that isn't available on Google Fonts or Fontsource?The rest of this lesson shows how to add web fonts "from scratch". Feel free to skip the rest of this lesson if you're happy with another option (though it may still be interesting to learn more about how web fonts work!).Converting formatsThe fonts that run on our computers typically come in.otfor.ttffile formats. These file formats were never intended to be used on the web, and their files tend to be relatively enormous.Our first order of business is to convert our font into a web-friendly format. You can use online converter tools likeFontsquirrel's webfont generator.The font-face tagHow do we tell the browser that we want to use a web font? The@font-faceat-rule has us covered:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-medium.woff2')format('woff2');font-weight:500;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-bold.woff2')format('woff2');font-weight:700;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2');font-weight:400;font-style:italic;}We need multiple statements because each font weight and style has its own file. In this case, I'm loading 3 different font weights (regular, medium, and bold) and an italic variant for the regular weight.The font file itself doesn't contain any "metadata" about what weight/style it is, so we need to link them up. That's what all the declarations in the@font-facestatement are doing. We specify the source for a set of characters (src), and then the associated metadata with that set (font-family,font-weight,font-style).IE supportIn the old days, we needed to supply 3 or 4 font files for each character set, because different browsers supported different formats.These days, things have gotten a lot better. The.woff2format is a modern, highly-optimized format that works across all major browsers, but not in Internet Explorer.My personal opinion is that web fonts are a nice-to-have. I think it's perfectly fine to use a built-in fallback font for IE users. But if you'd prefer that IE users have access to the web font, you'll need to specify a.wofffallback.Show lessYou should already have this file handy, if you used a web font generator or downloaded a web font bundle. They generally convert your font into several common formats.In your@font-facestatement, you can include multiple sources:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2'),url('/fonts/wotfard-regular-italic.woff')format('woff');font-weight:400;font-style:normal;}Be sure to put them in this order, so that.woff2comes first; the browser will download the first recognized format, and we want modern browsers to use.woff2(it tends to produce smaller filesizes).Our goal is to start loading the fonts ASAP, so I like to put these@font-facestatements right in theindex.html:<html><head><style>@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}/* Other @font-face statements omitted for brevity */</style></head>When those@font-facestatements are parsed by the browser, the font file declared undersrcwill be fetched and loaded. You can use the font in your CSS the way you'd use any font:.something{font-family:'Wotfard';font-weight:400;}Static files in ReactOne of the tricky things about React is that you can't access static files like fonts or images in the same way you would in a standard HTML/CSS project.It's beyond the scope of this course, but check out the following guides depending on your generator/meta-framework:create-react-appNext.jsGatsbyFaux bolds and italicsThe@font-facestatement lets us connect a specific font weight value (eg. 700) to a character set. When we use eitherfont-weight: boldorfont-weight: 700, the browser will use the heavier characters instead of the default ones.But what happens if we try to use bold text when we haven't supplied a bold font file?The browser can create "faux" bold text. It achieves this by expanding the thickness of every line in every font, stretching it out in all directions. This tends to create muddy, indistinct letters.For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

There are some downsides, though:Lots of amazing fonts aren't available on Google FontsSelf-hosted web fonts can perform betterGatsby creator Kyle Matthews discovered that self-hosting fonts cansave 300ms on desktop, and 1s+ on mobile 3G.Performance trade-offsI was initially surprised to learn that Google Fonts was a bit sluggish. Google is all about speed, why are their servers so slow?It's not actually about server speed, it's about the difference in approach.Show lessLet's explore what happens when we use Google's HTTP snippet:The browser fetches and parses ourindex.htmlfileThe browser sees the<link href="https://fonts.googleapis.com/css2">tag, and fires off a request to fetch a CSS fileThe browser parses the requested CSS file, and discovers that a web font needs to be downloaded fromhttps://fonts.gstatic.com, so it fires off a request for that font file.The CSS file is onfonts.googleapis.comand the font file itself is onfonts.gstatic.com. Because these are both external domains, some additional overhead is required (I'm not an HTTPS expert, but I believe there's some sort of handshake?).The request for the CSS file is blocking; this means that the browser is stuck waiting on this request before it can start rendering the page.When we use a self-hosted web font, by contrast, we can skip one of those steps: we can embed the CSS that fetches the font right in our HTML file, skipping Step #2. And because the font assets are on the same server, we can skip the third-party request overhead.In the old days, this could be offset by the fact that browsers had a global cache; it was possible that your users would already have a cached version of the font, because a different site sourced the font from the same CDN. Due to privacy concerns, however, browsers havestarted using partitioned caches. This means that your users will always need to download your web font on the first visit, even if they've visited other sites using the same font from the same CDN.If you're using Next.js 11 or higher, the framework willautomatically optimize this for you.Using modern toolingVercel, the company behind the Next.js framework, has released an interesting free resource calledFontsource.The idea with Fontsource is that it provides an easy-to-use method to install and useself-hostedweb fonts. It's built specifically for modern JS applications, letting you NPM install the fonts you wish to use. They support all Google Fonts, as well as additional open-source free-to-use fonts.You can learn more byreading their documentation.Angular v11+ has built-in support for Google Fonts, with configuration for inlining the fonts directly. You canlearn more in the Angular docs.The manual wayWhat if you want to use a font that isn't available on Google Fonts or Fontsource?The rest of this lesson shows how to add web fonts "from scratch". Feel free to skip the rest of this lesson if you're happy with another option (though it may still be interesting to learn more about how web fonts work!).Converting formatsThe fonts that run on our computers typically come in.otfor.ttffile formats. These file formats were never intended to be used on the web, and their files tend to be relatively enormous.Our first order of business is to convert our font into a web-friendly format. You can use online converter tools likeFontsquirrel's webfont generator.The font-face tagHow do we tell the browser that we want to use a web font? The@font-faceat-rule has us covered:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-medium.woff2')format('woff2');font-weight:500;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-bold.woff2')format('woff2');font-weight:700;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2');font-weight:400;font-style:italic;}We need multiple statements because each font weight and style has its own file. In this case, I'm loading 3 different font weights (regular, medium, and bold) and an italic variant for the regular weight.The font file itself doesn't contain any "metadata" about what weight/style it is, so we need to link them up. That's what all the declarations in the@font-facestatement are doing. We specify the source for a set of characters (src), and then the associated metadata with that set (font-family,font-weight,font-style).IE supportIn the old days, we needed to supply 3 or 4 font files for each character set, because different browsers supported different formats.These days, things have gotten a lot better. The.woff2format is a modern, highly-optimized format that works across all major browsers, but not in Internet Explorer.My personal opinion is that web fonts are a nice-to-have. I think it's perfectly fine to use a built-in fallback font for IE users. But if you'd prefer that IE users have access to the web font, you'll need to specify a.wofffallback.Show lessYou should already have this file handy, if you used a web font generator or downloaded a web font bundle. They generally convert your font into several common formats.In your@font-facestatement, you can include multiple sources:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2'),url('/fonts/wotfard-regular-italic.woff')format('woff');font-weight:400;font-style:normal;}Be sure to put them in this order, so that.woff2comes first; the browser will download the first recognized format, and we want modern browsers to use.woff2(it tends to produce smaller filesizes).Our goal is to start loading the fonts ASAP, so I like to put these@font-facestatements right in theindex.html:<html><head><style>@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}/* Other @font-face statements omitted for brevity */</style></head>When those@font-facestatements are parsed by the browser, the font file declared undersrcwill be fetched and loaded. You can use the font in your CSS the way you'd use any font:.something{font-family:'Wotfard';font-weight:400;}Static files in ReactOne of the tricky things about React is that you can't access static files like fonts or images in the same way you would in a standard HTML/CSS project.It's beyond the scope of this course, but check out the following guides depending on your generator/meta-framework:create-react-appNext.jsGatsbyFaux bolds and italicsThe@font-facestatement lets us connect a specific font weight value (eg. 700) to a character set. When we use eitherfont-weight: boldorfont-weight: 700, the browser will use the heavier characters instead of the default ones.But what happens if we try to use bold text when we haven't supplied a bold font file?The browser can create "faux" bold text. It achieves this by expanding the thickness of every line in every font, stretching it out in all directions. This tends to create muddy, indistinct letters.For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

Gatsby creator Kyle Matthews discovered that self-hosting fonts cansave 300ms on desktop, and 1s+ on mobile 3G.Performance trade-offsI was initially surprised to learn that Google Fonts was a bit sluggish. Google is all about speed, why are their servers so slow?It's not actually about server speed, it's about the difference in approach.Show lessLet's explore what happens when we use Google's HTTP snippet:The browser fetches and parses ourindex.htmlfileThe browser sees the<link href="https://fonts.googleapis.com/css2">tag, and fires off a request to fetch a CSS fileThe browser parses the requested CSS file, and discovers that a web font needs to be downloaded fromhttps://fonts.gstatic.com, so it fires off a request for that font file.The CSS file is onfonts.googleapis.comand the font file itself is onfonts.gstatic.com. Because these are both external domains, some additional overhead is required (I'm not an HTTPS expert, but I believe there's some sort of handshake?).The request for the CSS file is blocking; this means that the browser is stuck waiting on this request before it can start rendering the page.When we use a self-hosted web font, by contrast, we can skip one of those steps: we can embed the CSS that fetches the font right in our HTML file, skipping Step #2. And because the font assets are on the same server, we can skip the third-party request overhead.In the old days, this could be offset by the fact that browsers had a global cache; it was possible that your users would already have a cached version of the font, because a different site sourced the font from the same CDN. Due to privacy concerns, however, browsers havestarted using partitioned caches. This means that your users will always need to download your web font on the first visit, even if they've visited other sites using the same font from the same CDN.If you're using Next.js 11 or higher, the framework willautomatically optimize this for you.Using modern toolingVercel, the company behind the Next.js framework, has released an interesting free resource calledFontsource.The idea with Fontsource is that it provides an easy-to-use method to install and useself-hostedweb fonts. It's built specifically for modern JS applications, letting you NPM install the fonts you wish to use. They support all Google Fonts, as well as additional open-source free-to-use fonts.You can learn more byreading their documentation.Angular v11+ has built-in support for Google Fonts, with configuration for inlining the fonts directly. You canlearn more in the Angular docs.The manual wayWhat if you want to use a font that isn't available on Google Fonts or Fontsource?The rest of this lesson shows how to add web fonts "from scratch". Feel free to skip the rest of this lesson if you're happy with another option (though it may still be interesting to learn more about how web fonts work!).Converting formatsThe fonts that run on our computers typically come in.otfor.ttffile formats. These file formats were never intended to be used on the web, and their files tend to be relatively enormous.Our first order of business is to convert our font into a web-friendly format. You can use online converter tools likeFontsquirrel's webfont generator.The font-face tagHow do we tell the browser that we want to use a web font? The@font-faceat-rule has us covered:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-medium.woff2')format('woff2');font-weight:500;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-bold.woff2')format('woff2');font-weight:700;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2');font-weight:400;font-style:italic;}We need multiple statements because each font weight and style has its own file. In this case, I'm loading 3 different font weights (regular, medium, and bold) and an italic variant for the regular weight.The font file itself doesn't contain any "metadata" about what weight/style it is, so we need to link them up. That's what all the declarations in the@font-facestatement are doing. We specify the source for a set of characters (src), and then the associated metadata with that set (font-family,font-weight,font-style).IE supportIn the old days, we needed to supply 3 or 4 font files for each character set, because different browsers supported different formats.These days, things have gotten a lot better. The.woff2format is a modern, highly-optimized format that works across all major browsers, but not in Internet Explorer.My personal opinion is that web fonts are a nice-to-have. I think it's perfectly fine to use a built-in fallback font for IE users. But if you'd prefer that IE users have access to the web font, you'll need to specify a.wofffallback.Show lessYou should already have this file handy, if you used a web font generator or downloaded a web font bundle. They generally convert your font into several common formats.In your@font-facestatement, you can include multiple sources:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2'),url('/fonts/wotfard-regular-italic.woff')format('woff');font-weight:400;font-style:normal;}Be sure to put them in this order, so that.woff2comes first; the browser will download the first recognized format, and we want modern browsers to use.woff2(it tends to produce smaller filesizes).Our goal is to start loading the fonts ASAP, so I like to put these@font-facestatements right in theindex.html:<html><head><style>@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}/* Other @font-face statements omitted for brevity */</style></head>When those@font-facestatements are parsed by the browser, the font file declared undersrcwill be fetched and loaded. You can use the font in your CSS the way you'd use any font:.something{font-family:'Wotfard';font-weight:400;}Static files in ReactOne of the tricky things about React is that you can't access static files like fonts or images in the same way you would in a standard HTML/CSS project.It's beyond the scope of this course, but check out the following guides depending on your generator/meta-framework:create-react-appNext.jsGatsbyFaux bolds and italicsThe@font-facestatement lets us connect a specific font weight value (eg. 700) to a character set. When we use eitherfont-weight: boldorfont-weight: 700, the browser will use the heavier characters instead of the default ones.But what happens if we try to use bold text when we haven't supplied a bold font file?The browser can create "faux" bold text. It achieves this by expanding the thickness of every line in every font, stretching it out in all directions. This tends to create muddy, indistinct letters.For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

I was initially surprised to learn that Google Fonts was a bit sluggish. Google is all about speed, why are their servers so slow?It's not actually about server speed, it's about the difference in approach.Show lessLet's explore what happens when we use Google's HTTP snippet:The browser fetches and parses ourindex.htmlfileThe browser sees the<link href="https://fonts.googleapis.com/css2">tag, and fires off a request to fetch a CSS fileThe browser parses the requested CSS file, and discovers that a web font needs to be downloaded fromhttps://fonts.gstatic.com, so it fires off a request for that font file.The CSS file is onfonts.googleapis.comand the font file itself is onfonts.gstatic.com. Because these are both external domains, some additional overhead is required (I'm not an HTTPS expert, but I believe there's some sort of handshake?).The request for the CSS file is blocking; this means that the browser is stuck waiting on this request before it can start rendering the page.When we use a self-hosted web font, by contrast, we can skip one of those steps: we can embed the CSS that fetches the font right in our HTML file, skipping Step #2. And because the font assets are on the same server, we can skip the third-party request overhead.In the old days, this could be offset by the fact that browsers had a global cache; it was possible that your users would already have a cached version of the font, because a different site sourced the font from the same CDN. Due to privacy concerns, however, browsers havestarted using partitioned caches. This means that your users will always need to download your web font on the first visit, even if they've visited other sites using the same font from the same CDN.

It's not actually about server speed, it's about the difference in approach.

Let's explore what happens when we use Google's HTTP snippet:The browser fetches and parses ourindex.htmlfileThe browser sees the<link href="https://fonts.googleapis.com/css2">tag, and fires off a request to fetch a CSS fileThe browser parses the requested CSS file, and discovers that a web font needs to be downloaded fromhttps://fonts.gstatic.com, so it fires off a request for that font file.The CSS file is onfonts.googleapis.comand the font file itself is onfonts.gstatic.com. Because these are both external domains, some additional overhead is required (I'm not an HTTPS expert, but I believe there's some sort of handshake?).The request for the CSS file is blocking; this means that the browser is stuck waiting on this request before it can start rendering the page.When we use a self-hosted web font, by contrast, we can skip one of those steps: we can embed the CSS that fetches the font right in our HTML file, skipping Step #2. And because the font assets are on the same server, we can skip the third-party request overhead.In the old days, this could be offset by the fact that browsers had a global cache; it was possible that your users would already have a cached version of the font, because a different site sourced the font from the same CDN. Due to privacy concerns, however, browsers havestarted using partitioned caches. This means that your users will always need to download your web font on the first visit, even if they've visited other sites using the same font from the same CDN.




The CSS file is onfonts.googleapis.comand the font file itself is onfonts.gstatic.com. Because these are both external domains, some additional overhead is required (I'm not an HTTPS expert, but I believe there's some sort of handshake?).The request for the CSS file is blocking; this means that the browser is stuck waiting on this request before it can start rendering the page.When we use a self-hosted web font, by contrast, we can skip one of those steps: we can embed the CSS that fetches the font right in our HTML file, skipping Step #2. And because the font assets are on the same server, we can skip the third-party request overhead.In the old days, this could be offset by the fact that browsers had a global cache; it was possible that your users would already have a cached version of the font, because a different site sourced the font from the same CDN. Due to privacy concerns, however, browsers havestarted using partitioned caches. This means that your users will always need to download your web font on the first visit, even if they've visited other sites using the same font from the same CDN.



The request for the CSS file is blocking; this means that the browser is stuck waiting on this request before it can start rendering the page.When we use a self-hosted web font, by contrast, we can skip one of those steps: we can embed the CSS that fetches the font right in our HTML file, skipping Step #2. And because the font assets are on the same server, we can skip the third-party request overhead.In the old days, this could be offset by the fact that browsers had a global cache; it was possible that your users would already have a cached version of the font, because a different site sourced the font from the same CDN. Due to privacy concerns, however, browsers havestarted using partitioned caches. This means that your users will always need to download your web font on the first visit, even if they've visited other sites using the same font from the same CDN.

When we use a self-hosted web font, by contrast, we can skip one of those steps: we can embed the CSS that fetches the font right in our HTML file, skipping Step #2. And because the font assets are on the same server, we can skip the third-party request overhead.In the old days, this could be offset by the fact that browsers had a global cache; it was possible that your users would already have a cached version of the font, because a different site sourced the font from the same CDN. Due to privacy concerns, however, browsers havestarted using partitioned caches. This means that your users will always need to download your web font on the first visit, even if they've visited other sites using the same font from the same CDN.

In the old days, this could be offset by the fact that browsers had a global cache; it was possible that your users would already have a cached version of the font, because a different site sourced the font from the same CDN. Due to privacy concerns, however, browsers havestarted using partitioned caches. This means that your users will always need to download your web font on the first visit, even if they've visited other sites using the same font from the same CDN.

If you're using Next.js 11 or higher, the framework willautomatically optimize this for you.Using modern toolingVercel, the company behind the Next.js framework, has released an interesting free resource calledFontsource.The idea with Fontsource is that it provides an easy-to-use method to install and useself-hostedweb fonts. It's built specifically for modern JS applications, letting you NPM install the fonts you wish to use. They support all Google Fonts, as well as additional open-source free-to-use fonts.You can learn more byreading their documentation.Angular v11+ has built-in support for Google Fonts, with configuration for inlining the fonts directly. You canlearn more in the Angular docs.The manual wayWhat if you want to use a font that isn't available on Google Fonts or Fontsource?The rest of this lesson shows how to add web fonts "from scratch". Feel free to skip the rest of this lesson if you're happy with another option (though it may still be interesting to learn more about how web fonts work!).Converting formatsThe fonts that run on our computers typically come in.otfor.ttffile formats. These file formats were never intended to be used on the web, and their files tend to be relatively enormous.Our first order of business is to convert our font into a web-friendly format. You can use online converter tools likeFontsquirrel's webfont generator.The font-face tagHow do we tell the browser that we want to use a web font? The@font-faceat-rule has us covered:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-medium.woff2')format('woff2');font-weight:500;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-bold.woff2')format('woff2');font-weight:700;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2');font-weight:400;font-style:italic;}We need multiple statements because each font weight and style has its own file. In this case, I'm loading 3 different font weights (regular, medium, and bold) and an italic variant for the regular weight.The font file itself doesn't contain any "metadata" about what weight/style it is, so we need to link them up. That's what all the declarations in the@font-facestatement are doing. We specify the source for a set of characters (src), and then the associated metadata with that set (font-family,font-weight,font-style).IE supportIn the old days, we needed to supply 3 or 4 font files for each character set, because different browsers supported different formats.These days, things have gotten a lot better. The.woff2format is a modern, highly-optimized format that works across all major browsers, but not in Internet Explorer.My personal opinion is that web fonts are a nice-to-have. I think it's perfectly fine to use a built-in fallback font for IE users. But if you'd prefer that IE users have access to the web font, you'll need to specify a.wofffallback.Show lessYou should already have this file handy, if you used a web font generator or downloaded a web font bundle. They generally convert your font into several common formats.In your@font-facestatement, you can include multiple sources:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2'),url('/fonts/wotfard-regular-italic.woff')format('woff');font-weight:400;font-style:normal;}Be sure to put them in this order, so that.woff2comes first; the browser will download the first recognized format, and we want modern browsers to use.woff2(it tends to produce smaller filesizes).Our goal is to start loading the fonts ASAP, so I like to put these@font-facestatements right in theindex.html:<html><head><style>@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}/* Other @font-face statements omitted for brevity */</style></head>When those@font-facestatements are parsed by the browser, the font file declared undersrcwill be fetched and loaded. You can use the font in your CSS the way you'd use any font:.something{font-family:'Wotfard';font-weight:400;}Static files in ReactOne of the tricky things about React is that you can't access static files like fonts or images in the same way you would in a standard HTML/CSS project.It's beyond the scope of this course, but check out the following guides depending on your generator/meta-framework:create-react-appNext.jsGatsbyFaux bolds and italicsThe@font-facestatement lets us connect a specific font weight value (eg. 700) to a character set. When we use eitherfont-weight: boldorfont-weight: 700, the browser will use the heavier characters instead of the default ones.But what happens if we try to use bold text when we haven't supplied a bold font file?The browser can create "faux" bold text. It achieves this by expanding the thickness of every line in every font, stretching it out in all directions. This tends to create muddy, indistinct letters.For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

## Using modern tooling

Vercel, the company behind the Next.js framework, has released an interesting free resource calledFontsource.The idea with Fontsource is that it provides an easy-to-use method to install and useself-hostedweb fonts. It's built specifically for modern JS applications, letting you NPM install the fonts you wish to use. They support all Google Fonts, as well as additional open-source free-to-use fonts.You can learn more byreading their documentation.Angular v11+ has built-in support for Google Fonts, with configuration for inlining the fonts directly. You canlearn more in the Angular docs.The manual wayWhat if you want to use a font that isn't available on Google Fonts or Fontsource?The rest of this lesson shows how to add web fonts "from scratch". Feel free to skip the rest of this lesson if you're happy with another option (though it may still be interesting to learn more about how web fonts work!).Converting formatsThe fonts that run on our computers typically come in.otfor.ttffile formats. These file formats were never intended to be used on the web, and their files tend to be relatively enormous.Our first order of business is to convert our font into a web-friendly format. You can use online converter tools likeFontsquirrel's webfont generator.The font-face tagHow do we tell the browser that we want to use a web font? The@font-faceat-rule has us covered:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-medium.woff2')format('woff2');font-weight:500;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-bold.woff2')format('woff2');font-weight:700;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2');font-weight:400;font-style:italic;}We need multiple statements because each font weight and style has its own file. In this case, I'm loading 3 different font weights (regular, medium, and bold) and an italic variant for the regular weight.The font file itself doesn't contain any "metadata" about what weight/style it is, so we need to link them up. That's what all the declarations in the@font-facestatement are doing. We specify the source for a set of characters (src), and then the associated metadata with that set (font-family,font-weight,font-style).IE supportIn the old days, we needed to supply 3 or 4 font files for each character set, because different browsers supported different formats.These days, things have gotten a lot better. The.woff2format is a modern, highly-optimized format that works across all major browsers, but not in Internet Explorer.My personal opinion is that web fonts are a nice-to-have. I think it's perfectly fine to use a built-in fallback font for IE users. But if you'd prefer that IE users have access to the web font, you'll need to specify a.wofffallback.Show lessYou should already have this file handy, if you used a web font generator or downloaded a web font bundle. They generally convert your font into several common formats.In your@font-facestatement, you can include multiple sources:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2'),url('/fonts/wotfard-regular-italic.woff')format('woff');font-weight:400;font-style:normal;}Be sure to put them in this order, so that.woff2comes first; the browser will download the first recognized format, and we want modern browsers to use.woff2(it tends to produce smaller filesizes).Our goal is to start loading the fonts ASAP, so I like to put these@font-facestatements right in theindex.html:<html><head><style>@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}/* Other @font-face statements omitted for brevity */</style></head>When those@font-facestatements are parsed by the browser, the font file declared undersrcwill be fetched and loaded. You can use the font in your CSS the way you'd use any font:.something{font-family:'Wotfard';font-weight:400;}Static files in ReactOne of the tricky things about React is that you can't access static files like fonts or images in the same way you would in a standard HTML/CSS project.It's beyond the scope of this course, but check out the following guides depending on your generator/meta-framework:create-react-appNext.jsGatsbyFaux bolds and italicsThe@font-facestatement lets us connect a specific font weight value (eg. 700) to a character set. When we use eitherfont-weight: boldorfont-weight: 700, the browser will use the heavier characters instead of the default ones.But what happens if we try to use bold text when we haven't supplied a bold font file?The browser can create "faux" bold text. It achieves this by expanding the thickness of every line in every font, stretching it out in all directions. This tends to create muddy, indistinct letters.For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

The idea with Fontsource is that it provides an easy-to-use method to install and useself-hostedweb fonts. It's built specifically for modern JS applications, letting you NPM install the fonts you wish to use. They support all Google Fonts, as well as additional open-source free-to-use fonts.You can learn more byreading their documentation.Angular v11+ has built-in support for Google Fonts, with configuration for inlining the fonts directly. You canlearn more in the Angular docs.The manual wayWhat if you want to use a font that isn't available on Google Fonts or Fontsource?The rest of this lesson shows how to add web fonts "from scratch". Feel free to skip the rest of this lesson if you're happy with another option (though it may still be interesting to learn more about how web fonts work!).Converting formatsThe fonts that run on our computers typically come in.otfor.ttffile formats. These file formats were never intended to be used on the web, and their files tend to be relatively enormous.Our first order of business is to convert our font into a web-friendly format. You can use online converter tools likeFontsquirrel's webfont generator.The font-face tagHow do we tell the browser that we want to use a web font? The@font-faceat-rule has us covered:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-medium.woff2')format('woff2');font-weight:500;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-bold.woff2')format('woff2');font-weight:700;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2');font-weight:400;font-style:italic;}We need multiple statements because each font weight and style has its own file. In this case, I'm loading 3 different font weights (regular, medium, and bold) and an italic variant for the regular weight.The font file itself doesn't contain any "metadata" about what weight/style it is, so we need to link them up. That's what all the declarations in the@font-facestatement are doing. We specify the source for a set of characters (src), and then the associated metadata with that set (font-family,font-weight,font-style).IE supportIn the old days, we needed to supply 3 or 4 font files for each character set, because different browsers supported different formats.These days, things have gotten a lot better. The.woff2format is a modern, highly-optimized format that works across all major browsers, but not in Internet Explorer.My personal opinion is that web fonts are a nice-to-have. I think it's perfectly fine to use a built-in fallback font for IE users. But if you'd prefer that IE users have access to the web font, you'll need to specify a.wofffallback.Show lessYou should already have this file handy, if you used a web font generator or downloaded a web font bundle. They generally convert your font into several common formats.In your@font-facestatement, you can include multiple sources:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2'),url('/fonts/wotfard-regular-italic.woff')format('woff');font-weight:400;font-style:normal;}Be sure to put them in this order, so that.woff2comes first; the browser will download the first recognized format, and we want modern browsers to use.woff2(it tends to produce smaller filesizes).Our goal is to start loading the fonts ASAP, so I like to put these@font-facestatements right in theindex.html:<html><head><style>@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}/* Other @font-face statements omitted for brevity */</style></head>When those@font-facestatements are parsed by the browser, the font file declared undersrcwill be fetched and loaded. You can use the font in your CSS the way you'd use any font:.something{font-family:'Wotfard';font-weight:400;}Static files in ReactOne of the tricky things about React is that you can't access static files like fonts or images in the same way you would in a standard HTML/CSS project.It's beyond the scope of this course, but check out the following guides depending on your generator/meta-framework:create-react-appNext.jsGatsbyFaux bolds and italicsThe@font-facestatement lets us connect a specific font weight value (eg. 700) to a character set. When we use eitherfont-weight: boldorfont-weight: 700, the browser will use the heavier characters instead of the default ones.But what happens if we try to use bold text when we haven't supplied a bold font file?The browser can create "faux" bold text. It achieves this by expanding the thickness of every line in every font, stretching it out in all directions. This tends to create muddy, indistinct letters.For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

You can learn more byreading their documentation.Angular v11+ has built-in support for Google Fonts, with configuration for inlining the fonts directly. You canlearn more in the Angular docs.The manual wayWhat if you want to use a font that isn't available on Google Fonts or Fontsource?The rest of this lesson shows how to add web fonts "from scratch". Feel free to skip the rest of this lesson if you're happy with another option (though it may still be interesting to learn more about how web fonts work!).Converting formatsThe fonts that run on our computers typically come in.otfor.ttffile formats. These file formats were never intended to be used on the web, and their files tend to be relatively enormous.Our first order of business is to convert our font into a web-friendly format. You can use online converter tools likeFontsquirrel's webfont generator.The font-face tagHow do we tell the browser that we want to use a web font? The@font-faceat-rule has us covered:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-medium.woff2')format('woff2');font-weight:500;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-bold.woff2')format('woff2');font-weight:700;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2');font-weight:400;font-style:italic;}We need multiple statements because each font weight and style has its own file. In this case, I'm loading 3 different font weights (regular, medium, and bold) and an italic variant for the regular weight.The font file itself doesn't contain any "metadata" about what weight/style it is, so we need to link them up. That's what all the declarations in the@font-facestatement are doing. We specify the source for a set of characters (src), and then the associated metadata with that set (font-family,font-weight,font-style).IE supportIn the old days, we needed to supply 3 or 4 font files for each character set, because different browsers supported different formats.These days, things have gotten a lot better. The.woff2format is a modern, highly-optimized format that works across all major browsers, but not in Internet Explorer.My personal opinion is that web fonts are a nice-to-have. I think it's perfectly fine to use a built-in fallback font for IE users. But if you'd prefer that IE users have access to the web font, you'll need to specify a.wofffallback.Show lessYou should already have this file handy, if you used a web font generator or downloaded a web font bundle. They generally convert your font into several common formats.In your@font-facestatement, you can include multiple sources:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2'),url('/fonts/wotfard-regular-italic.woff')format('woff');font-weight:400;font-style:normal;}Be sure to put them in this order, so that.woff2comes first; the browser will download the first recognized format, and we want modern browsers to use.woff2(it tends to produce smaller filesizes).Our goal is to start loading the fonts ASAP, so I like to put these@font-facestatements right in theindex.html:<html><head><style>@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}/* Other @font-face statements omitted for brevity */</style></head>When those@font-facestatements are parsed by the browser, the font file declared undersrcwill be fetched and loaded. You can use the font in your CSS the way you'd use any font:.something{font-family:'Wotfard';font-weight:400;}Static files in ReactOne of the tricky things about React is that you can't access static files like fonts or images in the same way you would in a standard HTML/CSS project.It's beyond the scope of this course, but check out the following guides depending on your generator/meta-framework:create-react-appNext.jsGatsbyFaux bolds and italicsThe@font-facestatement lets us connect a specific font weight value (eg. 700) to a character set. When we use eitherfont-weight: boldorfont-weight: 700, the browser will use the heavier characters instead of the default ones.But what happens if we try to use bold text when we haven't supplied a bold font file?The browser can create "faux" bold text. It achieves this by expanding the thickness of every line in every font, stretching it out in all directions. This tends to create muddy, indistinct letters.For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

Angular v11+ has built-in support for Google Fonts, with configuration for inlining the fonts directly. You canlearn more in the Angular docs.The manual wayWhat if you want to use a font that isn't available on Google Fonts or Fontsource?The rest of this lesson shows how to add web fonts "from scratch". Feel free to skip the rest of this lesson if you're happy with another option (though it may still be interesting to learn more about how web fonts work!).Converting formatsThe fonts that run on our computers typically come in.otfor.ttffile formats. These file formats were never intended to be used on the web, and their files tend to be relatively enormous.Our first order of business is to convert our font into a web-friendly format. You can use online converter tools likeFontsquirrel's webfont generator.The font-face tagHow do we tell the browser that we want to use a web font? The@font-faceat-rule has us covered:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-medium.woff2')format('woff2');font-weight:500;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-bold.woff2')format('woff2');font-weight:700;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2');font-weight:400;font-style:italic;}We need multiple statements because each font weight and style has its own file. In this case, I'm loading 3 different font weights (regular, medium, and bold) and an italic variant for the regular weight.The font file itself doesn't contain any "metadata" about what weight/style it is, so we need to link them up. That's what all the declarations in the@font-facestatement are doing. We specify the source for a set of characters (src), and then the associated metadata with that set (font-family,font-weight,font-style).IE supportIn the old days, we needed to supply 3 or 4 font files for each character set, because different browsers supported different formats.These days, things have gotten a lot better. The.woff2format is a modern, highly-optimized format that works across all major browsers, but not in Internet Explorer.My personal opinion is that web fonts are a nice-to-have. I think it's perfectly fine to use a built-in fallback font for IE users. But if you'd prefer that IE users have access to the web font, you'll need to specify a.wofffallback.Show lessYou should already have this file handy, if you used a web font generator or downloaded a web font bundle. They generally convert your font into several common formats.In your@font-facestatement, you can include multiple sources:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2'),url('/fonts/wotfard-regular-italic.woff')format('woff');font-weight:400;font-style:normal;}Be sure to put them in this order, so that.woff2comes first; the browser will download the first recognized format, and we want modern browsers to use.woff2(it tends to produce smaller filesizes).Our goal is to start loading the fonts ASAP, so I like to put these@font-facestatements right in theindex.html:<html><head><style>@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}/* Other @font-face statements omitted for brevity */</style></head>When those@font-facestatements are parsed by the browser, the font file declared undersrcwill be fetched and loaded. You can use the font in your CSS the way you'd use any font:.something{font-family:'Wotfard';font-weight:400;}Static files in ReactOne of the tricky things about React is that you can't access static files like fonts or images in the same way you would in a standard HTML/CSS project.It's beyond the scope of this course, but check out the following guides depending on your generator/meta-framework:create-react-appNext.jsGatsbyFaux bolds and italicsThe@font-facestatement lets us connect a specific font weight value (eg. 700) to a character set. When we use eitherfont-weight: boldorfont-weight: 700, the browser will use the heavier characters instead of the default ones.But what happens if we try to use bold text when we haven't supplied a bold font file?The browser can create "faux" bold text. It achieves this by expanding the thickness of every line in every font, stretching it out in all directions. This tends to create muddy, indistinct letters.For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

## The manual way

What if you want to use a font that isn't available on Google Fonts or Fontsource?The rest of this lesson shows how to add web fonts "from scratch". Feel free to skip the rest of this lesson if you're happy with another option (though it may still be interesting to learn more about how web fonts work!).Converting formatsThe fonts that run on our computers typically come in.otfor.ttffile formats. These file formats were never intended to be used on the web, and their files tend to be relatively enormous.Our first order of business is to convert our font into a web-friendly format. You can use online converter tools likeFontsquirrel's webfont generator.The font-face tagHow do we tell the browser that we want to use a web font? The@font-faceat-rule has us covered:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-medium.woff2')format('woff2');font-weight:500;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-bold.woff2')format('woff2');font-weight:700;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2');font-weight:400;font-style:italic;}We need multiple statements because each font weight and style has its own file. In this case, I'm loading 3 different font weights (regular, medium, and bold) and an italic variant for the regular weight.The font file itself doesn't contain any "metadata" about what weight/style it is, so we need to link them up. That's what all the declarations in the@font-facestatement are doing. We specify the source for a set of characters (src), and then the associated metadata with that set (font-family,font-weight,font-style).IE supportIn the old days, we needed to supply 3 or 4 font files for each character set, because different browsers supported different formats.These days, things have gotten a lot better. The.woff2format is a modern, highly-optimized format that works across all major browsers, but not in Internet Explorer.My personal opinion is that web fonts are a nice-to-have. I think it's perfectly fine to use a built-in fallback font for IE users. But if you'd prefer that IE users have access to the web font, you'll need to specify a.wofffallback.Show lessYou should already have this file handy, if you used a web font generator or downloaded a web font bundle. They generally convert your font into several common formats.In your@font-facestatement, you can include multiple sources:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2'),url('/fonts/wotfard-regular-italic.woff')format('woff');font-weight:400;font-style:normal;}Be sure to put them in this order, so that.woff2comes first; the browser will download the first recognized format, and we want modern browsers to use.woff2(it tends to produce smaller filesizes).Our goal is to start loading the fonts ASAP, so I like to put these@font-facestatements right in theindex.html:<html><head><style>@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}/* Other @font-face statements omitted for brevity */</style></head>When those@font-facestatements are parsed by the browser, the font file declared undersrcwill be fetched and loaded. You can use the font in your CSS the way you'd use any font:.something{font-family:'Wotfard';font-weight:400;}Static files in ReactOne of the tricky things about React is that you can't access static files like fonts or images in the same way you would in a standard HTML/CSS project.It's beyond the scope of this course, but check out the following guides depending on your generator/meta-framework:create-react-appNext.jsGatsbyFaux bolds and italicsThe@font-facestatement lets us connect a specific font weight value (eg. 700) to a character set. When we use eitherfont-weight: boldorfont-weight: 700, the browser will use the heavier characters instead of the default ones.But what happens if we try to use bold text when we haven't supplied a bold font file?The browser can create "faux" bold text. It achieves this by expanding the thickness of every line in every font, stretching it out in all directions. This tends to create muddy, indistinct letters.For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

The rest of this lesson shows how to add web fonts "from scratch". Feel free to skip the rest of this lesson if you're happy with another option (though it may still be interesting to learn more about how web fonts work!).Converting formatsThe fonts that run on our computers typically come in.otfor.ttffile formats. These file formats were never intended to be used on the web, and their files tend to be relatively enormous.Our first order of business is to convert our font into a web-friendly format. You can use online converter tools likeFontsquirrel's webfont generator.The font-face tagHow do we tell the browser that we want to use a web font? The@font-faceat-rule has us covered:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-medium.woff2')format('woff2');font-weight:500;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-bold.woff2')format('woff2');font-weight:700;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2');font-weight:400;font-style:italic;}We need multiple statements because each font weight and style has its own file. In this case, I'm loading 3 different font weights (regular, medium, and bold) and an italic variant for the regular weight.The font file itself doesn't contain any "metadata" about what weight/style it is, so we need to link them up. That's what all the declarations in the@font-facestatement are doing. We specify the source for a set of characters (src), and then the associated metadata with that set (font-family,font-weight,font-style).IE supportIn the old days, we needed to supply 3 or 4 font files for each character set, because different browsers supported different formats.These days, things have gotten a lot better. The.woff2format is a modern, highly-optimized format that works across all major browsers, but not in Internet Explorer.My personal opinion is that web fonts are a nice-to-have. I think it's perfectly fine to use a built-in fallback font for IE users. But if you'd prefer that IE users have access to the web font, you'll need to specify a.wofffallback.Show lessYou should already have this file handy, if you used a web font generator or downloaded a web font bundle. They generally convert your font into several common formats.In your@font-facestatement, you can include multiple sources:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2'),url('/fonts/wotfard-regular-italic.woff')format('woff');font-weight:400;font-style:normal;}Be sure to put them in this order, so that.woff2comes first; the browser will download the first recognized format, and we want modern browsers to use.woff2(it tends to produce smaller filesizes).Our goal is to start loading the fonts ASAP, so I like to put these@font-facestatements right in theindex.html:<html><head><style>@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}/* Other @font-face statements omitted for brevity */</style></head>When those@font-facestatements are parsed by the browser, the font file declared undersrcwill be fetched and loaded. You can use the font in your CSS the way you'd use any font:.something{font-family:'Wotfard';font-weight:400;}Static files in ReactOne of the tricky things about React is that you can't access static files like fonts or images in the same way you would in a standard HTML/CSS project.It's beyond the scope of this course, but check out the following guides depending on your generator/meta-framework:create-react-appNext.jsGatsbyFaux bolds and italicsThe@font-facestatement lets us connect a specific font weight value (eg. 700) to a character set. When we use eitherfont-weight: boldorfont-weight: 700, the browser will use the heavier characters instead of the default ones.But what happens if we try to use bold text when we haven't supplied a bold font file?The browser can create "faux" bold text. It achieves this by expanding the thickness of every line in every font, stretching it out in all directions. This tends to create muddy, indistinct letters.For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

### Converting formats

The fonts that run on our computers typically come in.otfor.ttffile formats. These file formats were never intended to be used on the web, and their files tend to be relatively enormous.Our first order of business is to convert our font into a web-friendly format. You can use online converter tools likeFontsquirrel's webfont generator.The font-face tagHow do we tell the browser that we want to use a web font? The@font-faceat-rule has us covered:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-medium.woff2')format('woff2');font-weight:500;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-bold.woff2')format('woff2');font-weight:700;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2');font-weight:400;font-style:italic;}We need multiple statements because each font weight and style has its own file. In this case, I'm loading 3 different font weights (regular, medium, and bold) and an italic variant for the regular weight.The font file itself doesn't contain any "metadata" about what weight/style it is, so we need to link them up. That's what all the declarations in the@font-facestatement are doing. We specify the source for a set of characters (src), and then the associated metadata with that set (font-family,font-weight,font-style).IE supportIn the old days, we needed to supply 3 or 4 font files for each character set, because different browsers supported different formats.These days, things have gotten a lot better. The.woff2format is a modern, highly-optimized format that works across all major browsers, but not in Internet Explorer.My personal opinion is that web fonts are a nice-to-have. I think it's perfectly fine to use a built-in fallback font for IE users. But if you'd prefer that IE users have access to the web font, you'll need to specify a.wofffallback.Show lessYou should already have this file handy, if you used a web font generator or downloaded a web font bundle. They generally convert your font into several common formats.In your@font-facestatement, you can include multiple sources:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2'),url('/fonts/wotfard-regular-italic.woff')format('woff');font-weight:400;font-style:normal;}Be sure to put them in this order, so that.woff2comes first; the browser will download the first recognized format, and we want modern browsers to use.woff2(it tends to produce smaller filesizes).Our goal is to start loading the fonts ASAP, so I like to put these@font-facestatements right in theindex.html:<html><head><style>@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}/* Other @font-face statements omitted for brevity */</style></head>When those@font-facestatements are parsed by the browser, the font file declared undersrcwill be fetched and loaded. You can use the font in your CSS the way you'd use any font:.something{font-family:'Wotfard';font-weight:400;}Static files in ReactOne of the tricky things about React is that you can't access static files like fonts or images in the same way you would in a standard HTML/CSS project.It's beyond the scope of this course, but check out the following guides depending on your generator/meta-framework:create-react-appNext.jsGatsbyFaux bolds and italicsThe@font-facestatement lets us connect a specific font weight value (eg. 700) to a character set. When we use eitherfont-weight: boldorfont-weight: 700, the browser will use the heavier characters instead of the default ones.But what happens if we try to use bold text when we haven't supplied a bold font file?The browser can create "faux" bold text. It achieves this by expanding the thickness of every line in every font, stretching it out in all directions. This tends to create muddy, indistinct letters.For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.



Our first order of business is to convert our font into a web-friendly format. You can use online converter tools likeFontsquirrel's webfont generator.The font-face tagHow do we tell the browser that we want to use a web font? The@font-faceat-rule has us covered:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-medium.woff2')format('woff2');font-weight:500;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-bold.woff2')format('woff2');font-weight:700;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2');font-weight:400;font-style:italic;}We need multiple statements because each font weight and style has its own file. In this case, I'm loading 3 different font weights (regular, medium, and bold) and an italic variant for the regular weight.The font file itself doesn't contain any "metadata" about what weight/style it is, so we need to link them up. That's what all the declarations in the@font-facestatement are doing. We specify the source for a set of characters (src), and then the associated metadata with that set (font-family,font-weight,font-style).IE supportIn the old days, we needed to supply 3 or 4 font files for each character set, because different browsers supported different formats.These days, things have gotten a lot better. The.woff2format is a modern, highly-optimized format that works across all major browsers, but not in Internet Explorer.My personal opinion is that web fonts are a nice-to-have. I think it's perfectly fine to use a built-in fallback font for IE users. But if you'd prefer that IE users have access to the web font, you'll need to specify a.wofffallback.Show lessYou should already have this file handy, if you used a web font generator or downloaded a web font bundle. They generally convert your font into several common formats.In your@font-facestatement, you can include multiple sources:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2'),url('/fonts/wotfard-regular-italic.woff')format('woff');font-weight:400;font-style:normal;}Be sure to put them in this order, so that.woff2comes first; the browser will download the first recognized format, and we want modern browsers to use.woff2(it tends to produce smaller filesizes).Our goal is to start loading the fonts ASAP, so I like to put these@font-facestatements right in theindex.html:<html><head><style>@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}/* Other @font-face statements omitted for brevity */</style></head>When those@font-facestatements are parsed by the browser, the font file declared undersrcwill be fetched and loaded. You can use the font in your CSS the way you'd use any font:.something{font-family:'Wotfard';font-weight:400;}Static files in ReactOne of the tricky things about React is that you can't access static files like fonts or images in the same way you would in a standard HTML/CSS project.It's beyond the scope of this course, but check out the following guides depending on your generator/meta-framework:create-react-appNext.jsGatsbyFaux bolds and italicsThe@font-facestatement lets us connect a specific font weight value (eg. 700) to a character set. When we use eitherfont-weight: boldorfont-weight: 700, the browser will use the heavier characters instead of the default ones.But what happens if we try to use bold text when we haven't supplied a bold font file?The browser can create "faux" bold text. It achieves this by expanding the thickness of every line in every font, stretching it out in all directions. This tends to create muddy, indistinct letters.For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

### The font-face tag

How do we tell the browser that we want to use a web font? The@font-faceat-rule has us covered:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-medium.woff2')format('woff2');font-weight:500;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-bold.woff2')format('woff2');font-weight:700;font-style:normal;}@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2');font-weight:400;font-style:italic;}We need multiple statements because each font weight and style has its own file. In this case, I'm loading 3 different font weights (regular, medium, and bold) and an italic variant for the regular weight.The font file itself doesn't contain any "metadata" about what weight/style it is, so we need to link them up. That's what all the declarations in the@font-facestatement are doing. We specify the source for a set of characters (src), and then the associated metadata with that set (font-family,font-weight,font-style).IE supportIn the old days, we needed to supply 3 or 4 font files for each character set, because different browsers supported different formats.These days, things have gotten a lot better. The.woff2format is a modern, highly-optimized format that works across all major browsers, but not in Internet Explorer.My personal opinion is that web fonts are a nice-to-have. I think it's perfectly fine to use a built-in fallback font for IE users. But if you'd prefer that IE users have access to the web font, you'll need to specify a.wofffallback.Show lessYou should already have this file handy, if you used a web font generator or downloaded a web font bundle. They generally convert your font into several common formats.In your@font-facestatement, you can include multiple sources:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2'),url('/fonts/wotfard-regular-italic.woff')format('woff');font-weight:400;font-style:normal;}Be sure to put them in this order, so that.woff2comes first; the browser will download the first recognized format, and we want modern browsers to use.woff2(it tends to produce smaller filesizes).Our goal is to start loading the fonts ASAP, so I like to put these@font-facestatements right in theindex.html:<html><head><style>@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}/* Other @font-face statements omitted for brevity */</style></head>When those@font-facestatements are parsed by the browser, the font file declared undersrcwill be fetched and loaded. You can use the font in your CSS the way you'd use any font:.something{font-family:'Wotfard';font-weight:400;}Static files in ReactOne of the tricky things about React is that you can't access static files like fonts or images in the same way you would in a standard HTML/CSS project.It's beyond the scope of this course, but check out the following guides depending on your generator/meta-framework:create-react-appNext.jsGatsbyFaux bolds and italicsThe@font-facestatement lets us connect a specific font weight value (eg. 700) to a character set. When we use eitherfont-weight: boldorfont-weight: 700, the browser will use the heavier characters instead of the default ones.But what happens if we try to use bold text when we haven't supplied a bold font file?The browser can create "faux" bold text. It achieves this by expanding the thickness of every line in every font, stretching it out in all directions. This tends to create muddy, indistinct letters.For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.


```js
@font-face {  font-family: 'Wotfard';  src: url('/fonts/wotfard-regular.woff2') format('woff2');  font-weight: 400;  font-style: normal;}@font-face {  font-family: 'Wotfard';  src: url('/fonts/wotfard-medium.woff2') format('woff2');  font-weight: 500;  font-style: normal;}@font-face {  font-family: 'Wotfard';  src: url('/fonts/wotfard-bold.woff2') format('woff2');  font-weight: 700;  font-style: normal;}@font-face {  font-family: 'Wotfard';  src: url('/fonts/wotfard-regular-italic.woff2') format('woff2');  font-weight: 400;  font-style: italic;}
```

We need multiple statements because each font weight and style has its own file. In this case, I'm loading 3 different font weights (regular, medium, and bold) and an italic variant for the regular weight.The font file itself doesn't contain any "metadata" about what weight/style it is, so we need to link them up. That's what all the declarations in the@font-facestatement are doing. We specify the source for a set of characters (src), and then the associated metadata with that set (font-family,font-weight,font-style).IE supportIn the old days, we needed to supply 3 or 4 font files for each character set, because different browsers supported different formats.These days, things have gotten a lot better. The.woff2format is a modern, highly-optimized format that works across all major browsers, but not in Internet Explorer.My personal opinion is that web fonts are a nice-to-have. I think it's perfectly fine to use a built-in fallback font for IE users. But if you'd prefer that IE users have access to the web font, you'll need to specify a.wofffallback.Show lessYou should already have this file handy, if you used a web font generator or downloaded a web font bundle. They generally convert your font into several common formats.In your@font-facestatement, you can include multiple sources:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2'),url('/fonts/wotfard-regular-italic.woff')format('woff');font-weight:400;font-style:normal;}Be sure to put them in this order, so that.woff2comes first; the browser will download the first recognized format, and we want modern browsers to use.woff2(it tends to produce smaller filesizes).Our goal is to start loading the fonts ASAP, so I like to put these@font-facestatements right in theindex.html:<html><head><style>@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}/* Other @font-face statements omitted for brevity */</style></head>When those@font-facestatements are parsed by the browser, the font file declared undersrcwill be fetched and loaded. You can use the font in your CSS the way you'd use any font:.something{font-family:'Wotfard';font-weight:400;}Static files in ReactOne of the tricky things about React is that you can't access static files like fonts or images in the same way you would in a standard HTML/CSS project.It's beyond the scope of this course, but check out the following guides depending on your generator/meta-framework:create-react-appNext.jsGatsbyFaux bolds and italicsThe@font-facestatement lets us connect a specific font weight value (eg. 700) to a character set. When we use eitherfont-weight: boldorfont-weight: 700, the browser will use the heavier characters instead of the default ones.But what happens if we try to use bold text when we haven't supplied a bold font file?The browser can create "faux" bold text. It achieves this by expanding the thickness of every line in every font, stretching it out in all directions. This tends to create muddy, indistinct letters.For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

The font file itself doesn't contain any "metadata" about what weight/style it is, so we need to link them up. That's what all the declarations in the@font-facestatement are doing. We specify the source for a set of characters (src), and then the associated metadata with that set (font-family,font-weight,font-style).IE supportIn the old days, we needed to supply 3 or 4 font files for each character set, because different browsers supported different formats.These days, things have gotten a lot better. The.woff2format is a modern, highly-optimized format that works across all major browsers, but not in Internet Explorer.My personal opinion is that web fonts are a nice-to-have. I think it's perfectly fine to use a built-in fallback font for IE users. But if you'd prefer that IE users have access to the web font, you'll need to specify a.wofffallback.Show lessYou should already have this file handy, if you used a web font generator or downloaded a web font bundle. They generally convert your font into several common formats.In your@font-facestatement, you can include multiple sources:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2'),url('/fonts/wotfard-regular-italic.woff')format('woff');font-weight:400;font-style:normal;}Be sure to put them in this order, so that.woff2comes first; the browser will download the first recognized format, and we want modern browsers to use.woff2(it tends to produce smaller filesizes).Our goal is to start loading the fonts ASAP, so I like to put these@font-facestatements right in theindex.html:<html><head><style>@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}/* Other @font-face statements omitted for brevity */</style></head>When those@font-facestatements are parsed by the browser, the font file declared undersrcwill be fetched and loaded. You can use the font in your CSS the way you'd use any font:.something{font-family:'Wotfard';font-weight:400;}Static files in ReactOne of the tricky things about React is that you can't access static files like fonts or images in the same way you would in a standard HTML/CSS project.It's beyond the scope of this course, but check out the following guides depending on your generator/meta-framework:create-react-appNext.jsGatsbyFaux bolds and italicsThe@font-facestatement lets us connect a specific font weight value (eg. 700) to a character set. When we use eitherfont-weight: boldorfont-weight: 700, the browser will use the heavier characters instead of the default ones.But what happens if we try to use bold text when we haven't supplied a bold font file?The browser can create "faux" bold text. It achieves this by expanding the thickness of every line in every font, stretching it out in all directions. This tends to create muddy, indistinct letters.For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.






In the old days, we needed to supply 3 or 4 font files for each character set, because different browsers supported different formats.These days, things have gotten a lot better. The.woff2format is a modern, highly-optimized format that works across all major browsers, but not in Internet Explorer.My personal opinion is that web fonts are a nice-to-have. I think it's perfectly fine to use a built-in fallback font for IE users. But if you'd prefer that IE users have access to the web font, you'll need to specify a.wofffallback.Show lessYou should already have this file handy, if you used a web font generator or downloaded a web font bundle. They generally convert your font into several common formats.In your@font-facestatement, you can include multiple sources:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2'),url('/fonts/wotfard-regular-italic.woff')format('woff');font-weight:400;font-style:normal;}Be sure to put them in this order, so that.woff2comes first; the browser will download the first recognized format, and we want modern browsers to use.woff2(it tends to produce smaller filesizes).

These days, things have gotten a lot better. The.woff2format is a modern, highly-optimized format that works across all major browsers, but not in Internet Explorer.My personal opinion is that web fonts are a nice-to-have. I think it's perfectly fine to use a built-in fallback font for IE users. But if you'd prefer that IE users have access to the web font, you'll need to specify a.wofffallback.Show lessYou should already have this file handy, if you used a web font generator or downloaded a web font bundle. They generally convert your font into several common formats.In your@font-facestatement, you can include multiple sources:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2'),url('/fonts/wotfard-regular-italic.woff')format('woff');font-weight:400;font-style:normal;}Be sure to put them in this order, so that.woff2comes first; the browser will download the first recognized format, and we want modern browsers to use.woff2(it tends to produce smaller filesizes).


My personal opinion is that web fonts are a nice-to-have. I think it's perfectly fine to use a built-in fallback font for IE users. But if you'd prefer that IE users have access to the web font, you'll need to specify a.wofffallback.


You should already have this file handy, if you used a web font generator or downloaded a web font bundle. They generally convert your font into several common formats.In your@font-facestatement, you can include multiple sources:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2'),url('/fonts/wotfard-regular-italic.woff')format('woff');font-weight:400;font-style:normal;}Be sure to put them in this order, so that.woff2comes first; the browser will download the first recognized format, and we want modern browsers to use.woff2(it tends to produce smaller filesizes).

In your@font-facestatement, you can include multiple sources:@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular-italic.woff2')format('woff2'),url('/fonts/wotfard-regular-italic.woff')format('woff');font-weight:400;font-style:normal;}Be sure to put them in this order, so that.woff2comes first; the browser will download the first recognized format, and we want modern browsers to use.woff2(it tends to produce smaller filesizes).


```js
@font-face {  font-family: 'Wotfard';  src:    url('/fonts/wotfard-regular-italic.woff2') format('woff2'),    url('/fonts/wotfard-regular-italic.woff') format('woff');  font-weight: 400;  font-style: normal;}
```

Be sure to put them in this order, so that.woff2comes first; the browser will download the first recognized format, and we want modern browsers to use.woff2(it tends to produce smaller filesizes).



Our goal is to start loading the fonts ASAP, so I like to put these@font-facestatements right in theindex.html:<html><head><style>@font-face{font-family:'Wotfard';src:url('/fonts/wotfard-regular.woff2')format('woff2');font-weight:400;font-style:normal;}/* Other @font-face statements omitted for brevity */</style></head>When those@font-facestatements are parsed by the browser, the font file declared undersrcwill be fetched and loaded. You can use the font in your CSS the way you'd use any font:.something{font-family:'Wotfard';font-weight:400;}Static files in ReactOne of the tricky things about React is that you can't access static files like fonts or images in the same way you would in a standard HTML/CSS project.It's beyond the scope of this course, but check out the following guides depending on your generator/meta-framework:create-react-appNext.jsGatsbyFaux bolds and italicsThe@font-facestatement lets us connect a specific font weight value (eg. 700) to a character set. When we use eitherfont-weight: boldorfont-weight: 700, the browser will use the heavier characters instead of the default ones.But what happens if we try to use bold text when we haven't supplied a bold font file?The browser can create "faux" bold text. It achieves this by expanding the thickness of every line in every font, stretching it out in all directions. This tends to create muddy, indistinct letters.For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.



```js
<html><head>  <style>    @font-face {      font-family: 'Wotfard';      src: url('/fonts/wotfard-regular.woff2') format('woff2');      font-weight: 400;      font-style: normal;    }    /* Other @font-face statements omitted for brevity */  </style></head>
```

When those@font-facestatements are parsed by the browser, the font file declared undersrcwill be fetched and loaded. You can use the font in your CSS the way you'd use any font:.something{font-family:'Wotfard';font-weight:400;}Static files in ReactOne of the tricky things about React is that you can't access static files like fonts or images in the same way you would in a standard HTML/CSS project.It's beyond the scope of this course, but check out the following guides depending on your generator/meta-framework:create-react-appNext.jsGatsbyFaux bolds and italicsThe@font-facestatement lets us connect a specific font weight value (eg. 700) to a character set. When we use eitherfont-weight: boldorfont-weight: 700, the browser will use the heavier characters instead of the default ones.But what happens if we try to use bold text when we haven't supplied a bold font file?The browser can create "faux" bold text. It achieves this by expanding the thickness of every line in every font, stretching it out in all directions. This tends to create muddy, indistinct letters.For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.



```js
.something {  font-family: 'Wotfard';  font-weight: 400;}
```

One of the tricky things about React is that you can't access static files like fonts or images in the same way you would in a standard HTML/CSS project.It's beyond the scope of this course, but check out the following guides depending on your generator/meta-framework:create-react-appNext.jsGatsby

It's beyond the scope of this course, but check out the following guides depending on your generator/meta-framework:create-react-appNext.jsGatsby

## Faux bolds and italics

The@font-facestatement lets us connect a specific font weight value (eg. 700) to a character set. When we use eitherfont-weight: boldorfont-weight: 700, the browser will use the heavier characters instead of the default ones.But what happens if we try to use bold text when we haven't supplied a bold font file?The browser can create "faux" bold text. It achieves this by expanding the thickness of every line in every font, stretching it out in all directions. This tends to create muddy, indistinct letters.For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.




But what happens if we try to use bold text when we haven't supplied a bold font file?The browser can create "faux" bold text. It achieves this by expanding the thickness of every line in every font, stretching it out in all directions. This tends to create muddy, indistinct letters.For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

The browser can create "faux" bold text. It achieves this by expanding the thickness of every line in every font, stretching it out in all directions. This tends to create muddy, indistinct letters.For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

For example, here's a side-by-side of a font'struebold, vs. the browser's imitation:True boldFaux boldToggleExpandWhen font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

### True bold

![Screenshot of the words “This sentence has some bold words”, with true bold lettering](./images/ANLwqmDnhwPEAAAAAElFTkSuQmCC)

### Faux bold

![Screenshot of the words “This sentence has some bold words”, with emulated bold lettering](./images/u4E3J4d7zGwAAAABJRU5ErkJggg==)

When font designers create bold variants of a font, they're very intentional and strategic about how they change the characters, optimizing for aesthetics and readability. Browser-generated faux-bolds are much less sophisticated; they just make the lines thicker.Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

Similarly, when it comes to italics, the browser simply slants the letters, whereas true italics use alternate characters:True italicFaux italicToggleExpandTo be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

### True italic

![Screenshot of the words “This sentence has some italic words”, with true italic lettering](./images/okBAAAAAElFTkSuQmCC)

### Faux italic

![Screenshot of the words “This sentence has some italic words”, with faux italic lettering](./images/kJJFEyAAAAAElFTkSuQmCC)

To be fair, I'm using a highly-stylized font (Playfair Display) in these examples. The differences can be more subtle than this. But it's the kind of small detail that can make a surprisingly big impact on how polished/professional your site/application appears to users.Number roundingLet's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

Let's suppose that we decide on including two font styles from our web font: the 400 weight, and the 800 weight.What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

What do you suppose happens when you use a "bold" font weight?.thing{font-weight:bold;}Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

```js
.thing {  font-weight: bold;}
```

Or, what if you use a number in-between the numbers you've set up?.thing{font-weight:700;}Show lessEarlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

```js
.thing {  font-weight: 700;}
```

Earlier, precision was really important: both of these statements would cause the browser to use a faux-bold, thickening the 400 weight rather than using the 800 weight.In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

In the modern age, though, the browser is a bit smarter. In my tests, all major browsers will use the 800-weight font, for both statements. It appears to "round" to the closest available weight.I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.

I've heard that theboldkeyword works differently than the700valueifthe web font isn't available at that weight, but I haven't been able to find any differences between the two, across major browsers. You canrun my testto see if you get a different result!Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.



Even though the browsers handle this situation more gracefully, I still suggest sticking to the font weights that are available, to avoid confusion. I also suggest using numbers (700) rather than keywords (bold), because it's more explicit.






